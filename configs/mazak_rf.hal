# this file contains the HAL configuration for Roland's Mazak
#
# first load I/O drivers.  This retrofit uses three different I/O devices
#
# 1) MOTENC-Lite card, for analog outs to drives, encoder feedback, and 
#     some digital I/O.
#
loadrt hal_motenc

# 2) AXIOM AX5214H card, for 48 digital I/O
#     we are using 32 inputs and 16 outputs, with the outputs on port
#     C, which can be converted to inputs 4 bits at a time.
#
loadrt hal_ax5214h cfg="0x220_iiooiioo"

# 3) Parallel Port, driving PMDX-122 card.  This provides a charge pump
#     type watchdog, and also provides a small number of inputs that 
#     can be sampled at a higher rate.  The jogwheel comes in thru this
#     card and is counted in software.
#
loadrt hal_parport cfg="0x0378_in"

# I/O Mapping - Physical I/O points to driver pins
# --------------------------------------------------------
# OPTO-22 board IO-1 input  module  0 is ax5214h.0.in-24
# OPTO-22 board IO-1 input  module  1 is ax5214h.0.in-25
#    "                  "                      "
# OPTO-22 board IO-1 input  module 14 is ax5214h.0.in-38
# OPTO-22 board IO-1 input  module 15 is ax5214h.0.in-39
# OPTO-22 board IO-1 output module 16 is ax5214h.0.out-40
# OPTO-22 board IO-1 output module 17 is ax5214h.0.out-41
#    "                  "                      "
# OPTO-22 board IO-1 output module 22 is ax5214h.0.out-46
# OPTO-22 board IO-1 output module 23 is ax5214h.0.out-47
# --------------------------------------------------------
# OPTO-22 board IO-2 input  module  0 is ax5214h.0.in-00
# OPTO-22 board IO-2 input  module  1 is ax5214h.0.in-01
#    "                  "                      "
# OPTO-22 board IO-2 input  module 14 is ax5214h.0.in-14
# OPTO-22 board IO-2 input  module 15 is ax5214h.0.in-15
# OPTO-22 board IO-2 output module 16 is ax5214h.0.out-16
# OPTO-22 board IO-2 output module 17 is ax5214h.0.out-17
#    "                  "                      "
# OPTO-22 board IO-2 output module 22 is ax5214h.0.out-22
# OPTO-22 board IO-2 output module 23 is ax5214h.0.out-23
# --------------------------------------------------------
# OPTO-22 board IO-3 output module  0 is motenc.3.out-15
# OPTO-22 board IO-3 output module  1 is motenc.3.out-14
#    "                  "                      "
# OPTO-22 board IO-3 output module  6 is motenc.3.out-01
# OPTO-22 board IO-3 output module  7 is motenc.3.out-00
# OPTO-22 board IO-3 input  module  8 is motenc.3.in-16
# OPTO-22 board IO-3 input  module  9 is motenc.3.in-17
#    "                  "                      "
# OPTO-22 board IO-3 input  module 22 is motenc.3.in-30
# OPTO-22 board IO-3 input  module 23 is motenc.3.in-31
# --------------------------------------------------------
# Breakout board IO-4 output chan  0 is motenc.3.out-00
# Breakout board IO-4 output chan  1 is motenc.3.out-01
#    "                  "                      "
# Breakout board IO-4 output chan  6 is motenc.3.out-06
# Breakout board IO-4 output chan  7 is motenc.3.out-07
# Breakout board IO-4 input  chan  0 is motenc.3.in-00
# Breakout board IO-4 input  chan  1 is motenc.3.in-01
#    "                  "                      "
# Breakout board IO-4 input  chan 14 is motenc.3.in-14
# Breakout board IO-4 input  chan 15 is motenc.3.in-15
# --------------------------------------------------------

# Now we load some more HAL components:
#
# using the estop logic from "blocks", at least for now
loadrt blocks n_estop=1 ddt=2 limit3=1

# Software encoder counter, for the jogwheel, and possibly a future
# small manual encoder for a feedrate override knob.
#	
loadrt encoder num_chan=1

# PID loops for axis control
#
loadrt pid numchan=3

# classicladder for machine logic
# (load the realtime portion)
loadrt classicladder_rt numRungs=50 numBits=50 numWords=4 numTimers=10 numMonostables=10 numPhysInputs=20 numPhysOutputs=20 numArithmExpr=4 numSections=4


# invoke the user part of CL to silently load the program
loadusr -w bin/classicladder --nogui configs/mazak_rf.clp

# load the realtime part of halscope
loadrt scope_rt

# -----------------------------------------------

# connect I/O driver functions to thread(s)
#
# NOTE: this would be _much_ easier if we allowed HAL to
# load all the realtime modules, including the core EMC
# ones.  As it is however, the EMC motion controller is
# loaded by the run script, so we need to make sure that 
# input drivers execute before the motion module, and the
# PID calcs and output drivers run after the motion module.
# The number at the end of each line is the position in
# the thread.
addf motenc.3.encoder_read          servo-thread 1
addf motenc.3.digital_in_read       servo-thread 2
addf ax5214h.0.read                 servo-thread 3
addf estop.0                        servo-thread 4
addf encoder.capture_position       servo-thread 5
addf motenc.3.adc_read              servo-thread 6

# ladder logic is executed once all the inputs are read
addf classicladder.0.refresh        servo-thread 7

addf limit3.0 servo-thread 8

# pid calculations are done after the motion module
# has determined new position commands.  By passing
# -1 to the addf command, the functions are installed
# after the motion module.
addf pid.0.do_pid_calcs             servo-thread -1
addf pid.1.do_pid_calcs             servo-thread -1
addf pid.2.do_pid_calcs             servo-thread -1

# output drivers are loaded last
addf motenc.3.dac_write             servo-thread -1
addf motenc.3.digital_out_write     servo-thread -1
addf ax5214h.0.write                servo-thread -1
addf parport.0.write                servo-thread -1

# the base thread (fast thread) isn't needed for step pulse 
# generation since this is a servo machine.  However we use
# it to sample the jogwheel signals and count them in software

addf parport.0.read                 base-thread
addf encoder.update_counters        base-thread

# -------------------------------------------------

# Next, create signals with meaningfull names, and attach them to the
#  physical pins.  There are a lot of these, so they are broken up

# ---------------------------------------------------
# ESTOP and related signals
newsig estop-ok-in bit
linksp estop-ok-in ax5214h.0.in-24
linksp estop-ok-in estop.0.ok-in
newsig estop-ok-out bit
linksp estop-ok-out parport.0.pin-01-out
linksp estop-ok-out estop.0.ok-out
newsig emc-estop-out bit
linksp emc-estop-out iocontrol.0.estop-out
linksp emc-estop-out estop.0.fault-in
newsig emc-estop-in bit
linksp emc-estop-in estop.0.fault-out
linksp emc-estop-in iocontrol.0.estop-in
newsig estop-reset bit
linksp estop-reset iocontrol.0.estop-reset
linksp estop-reset estop.0.reset
newsig charge-pump bit
linksp charge-pump estop.0.watchdog
linksp charge-pump parport.0.pin-17-out

# servo power supply control
newsig AP1 bit
linksp AP1 motenc.3.out-00
newsig AP2 bit
linksp AP2 motenc.3.out-01

# servo amp enable (only one, driven by axis 0)
newsig servo-enable bit
linksp servo-enable motenc.3.out-02
linksp servo-enable axis.0.amp-enable-out

# servo amp fault signals
# the signals from the amps are actually "not running"
# they are asserted when the amp is faulted, OR just
# disabled.  So we use the inverse and call them "running"
newsig X-amp-running bit
linksp X-amp-running motenc.3.in-12-not
newsig Y-amp-running bit
linksp Y-amp-running motenc.3.in-13-not
newsig Z-amp-running bit
linksp Z-amp-running motenc.3.in-14-not
# these are the real fault signals, and go to the motion 
# controller, they are derived from the ones above by
# ladder logic
newsig X-amp-fault bit
linksp X-amp-fault axis.0.amp-fault-in
newsig Y-amp-fault bit
linksp Y-amp-fault axis.1.amp-fault-in
newsig Z-amp-fault bit
linksp Z-amp-fault axis.2.amp-fault-in

# motion enable - this signal prevents the motion controller
# from starting unless everything is OK (comes from ladder)
newsig motion-enable bit
linksp motion-enable motion.enable

# Limit switches
# (the switches are NC, and open when hit, so
# we invert the signals by using the -not input
# pin - the result is limit signals that are 
# TRUE when the machine is on the limit.)
newsig X-lim-plus bit
linksp X-lim-plus motenc.3.in-00-not
linksp X-lim-plus axis.0.pos-lim-sw-in
newsig X-lim-minus bit
linksp X-lim-minus motenc.3.in-01-not
linksp X-lim-minus axis.0.neg-lim-sw-in
newsig Y-lim-plus bit
linksp Y-lim-plus motenc.3.in-02-not
linksp Y-lim-plus axis.1.pos-lim-sw-in
newsig Y-lim-minus bit
linksp Y-lim-minus motenc.3.in-03-not
linksp Y-lim-minus axis.1.neg-lim-sw-in
newsig Z-lim-plus bit
linksp Z-lim-plus motenc.3.in-04-not
linksp Z-lim-plus axis.2.pos-lim-sw-in
newsig Z-lim-minus bit
linksp Z-lim-minus motenc.3.in-05-not
linksp Z-lim-minus axis.2.neg-lim-sw-in

# Home switches
# (the switches are NC, see note above)
newsig X-home bit
linksp X-home motenc.3.in-08-not
linksp X-home axis.0.home-sw-in
newsig Y-home bit
linksp Y-home motenc.3.in-09-not
linksp Y-home axis.1.home-sw-in
newsig Z-home bit
linksp Z-home motenc.3.in-10-not
linksp Z-home axis.2.home-sw-in

# spindle related signals
# ready (from drive to PC)
newsig spindle-ready bit
linksp spindle-ready motenc.3.in-14-not
# run (from PC to drive)
newsig spindle-run bit
linksp spindle-run motenc.3.out-03
# speed speed command (from PC to drive)
# note this is motor speed, not spindle
# speed (because of the gearbox)
newsig spindle-mtr-spd-cmd float
linksp spindle-mtr-spd-cmd motenc.3.dac-03-value
# spindle current feedback (from drive to PC)
newsig spindle-amps float
linksp spindle-amps motenc.3.adc-03-value

# jogwheel signals
newsig jogwheel-phA bit
newsig jogwheel-phB bit
linksp jogwheel-phA parport.0.pin-12-in
linksp jogwheel-phB parport.0.pin-11-in
# route signals to software encoder counter
linksp jogwheel-phA encoder.0.phase-A
linksp jogwheel-phB encoder.0.phase-B
# jogwheel output
newsig jogwheel-counts s32
linksp jogwheel-counts encoder.0.counts


# -----------------------------------------------------
# encoders - signals and scaling
#
# position in counts
newsig X-enc-counts s32
newsig Y-enc-counts s32
newsig Z-enc-counts s32
linksp X-enc-counts motenc.3.enc-00-count
linksp Y-enc-counts motenc.3.enc-01-count
linksp Z-enc-counts motenc.3.enc-02-count

# scaling to get inches (scale comes from ini file)
setp motenc.3.enc-00-scale [AXIS_0]INPUT_SCALE
setp motenc.3.enc-01-scale [AXIS_1]INPUT_SCALE
setp motenc.3.enc-02-scale [AXIS_2]INPUT_SCALE

# position in inches
newsig X-enc-pos float
newsig Y-enc-pos float
newsig Z-enc-pos float
linksp X-enc-pos motenc.3.enc-00-position
linksp Y-enc-pos motenc.3.enc-01-position
linksp Z-enc-pos motenc.3.enc-02-position

# -----------------------------------------------------
# DACs - output to servo amps
#
newsig X-volts float
newsig Y-volts float
newsig Z-volts float
linksp X-volts motenc.3.dac-00-value
linksp Y-volts motenc.3.dac-01-value
linksp Z-volts motenc.3.dac-02-value
# get scale and offset from the ini file
setp motenc.3.dac-00-gain [AXIS_0]OUTPUT_SCALE
setp motenc.3.dac-01-gain [AXIS_1]OUTPUT_SCALE
setp motenc.3.dac-02-gain [AXIS_2]OUTPUT_SCALE
setp motenc.3.dac-00-offset [AXIS_0]OUTPUT_OFFSET
setp motenc.3.dac-01-offset [AXIS_1]OUTPUT_OFFSET
setp motenc.3.dac-02-offset [AXIS_2]OUTPUT_OFFSET

# -----------------------------------------------------
# ADCs - servo amp current feedback
#
newsig X-amps float
newsig Y-amps float
newsig Z-amps float
linksp X-amps motenc.3.adc-00-value
linksp Y-amps motenc.3.adc-01-value
linksp Z-amps motenc.3.adc-02-value
# set scale and offset (need to calibrate this)
setp motenc.3.adc-00-gain 1.0
setp motenc.3.adc-01-gain 1.0
setp motenc.3.adc-02-gain 1.0
setp motenc.3.adc-00-offset 0.0
setp motenc.3.adc-01-offset 0.0
setp motenc.3.adc-02-offset 0.0

# -----------------------------------------------------
# PIDs - position control
#

# signals for position command
newsig X-pos-cmd float
newsig Y-pos-cmd float
newsig Z-pos-cmd float
# hook the motion controller outputs to the position command
linksp X-pos-cmd axis.0.motor-pos-cmd
linksp Y-pos-cmd axis.1.motor-pos-cmd
# and to the PID inputs
linksp X-pos-cmd pid.0.command
linksp Y-pos-cmd pid.1.command

# hook encoders to PID feedback
linksp X-enc-pos pid.0.feedback
linksp Y-enc-pos pid.1.feedback
linksp Z-enc-pos pid.2.feedback
# and to motion controller
linksp X-enc-pos axis.0.motor-pos-fb
linksp Y-enc-pos axis.1.motor-pos-fb
linksp Z-enc-pos axis.2.motor-pos-fb

# hook PID outputs to DACs
linksp X-volts pid.0.output
linksp Y-volts pid.1.output
#linksp Z-volts pid.2.output

# use 'servo-enable' to enable PID blocks
linksp servo-enable pid.0.enable
linksp servo-enable pid.1.enable
linksp servo-enable pid.2.enable

# send the position feedback and command thru 
# differentiators to generate velocity signals
# link the differentiator functions into the code
addf ddt.0 servo-thread
addf ddt.1 servo-thread
# define the signals, and hook them up
newsig vel-cmd float
newsig vel-fb float
linksp Y-pos-cmd ddt.0.in
linksp vel-cmd ddt.0.out
linksp Y-enc-pos ddt.1.in
linksp vel-fb ddt.1.out
# the actual command is a ramp, generated by putting a step into a second order limiter
newsig pos-cmd float
linksp pos-cmd limit3.0.in
linksp Z-pos-cmd limit3.0.out
# set the limits
setp limit3.0.min -2.0
setp limit3.0.max  2.0
setp limit3.0.maxv 0.5
setp limit3.0.maxa 5

# get tuning params from ini file
setp pid.0.deadband [AXIS_0]DEADBAND
setp pid.0.Pgain [AXIS_0]PGAIN
setp pid.0.Igain [AXIS_0]IGAIN
setp pid.0.Dgain [AXIS_0]DGAIN
setp pid.0.FF0 [AXIS_0]FF0
setp pid.0.FF1 [AXIS_0]FF1
setp pid.0.bias [AXIS_0]BIAS
setp pid.1.deadband [AXIS_1]DEADBAND
setp pid.1.Pgain [AXIS_1]PGAIN
setp pid.1.Igain [AXIS_1]IGAIN
setp pid.1.Dgain [AXIS_1]DGAIN
setp pid.1.FF0 [AXIS_1]FF0
setp pid.1.FF1 [AXIS_1]FF1
setp pid.1.bias [AXIS_1]BIAS
setp pid.2.deadband [AXIS_2]DEADBAND
setp pid.2.Pgain [AXIS_2]PGAIN
setp pid.2.Igain [AXIS_2]IGAIN
setp pid.2.Dgain [AXIS_2]DGAIN
setp pid.2.FF0 [AXIS_2]FF0
setp pid.2.FF1 [AXIS_2]FF1
setp pid.2.bias [AXIS_2]BIAS
# get maximum (and minimum) output volts from ini file
setp pid.0.maxoutput [AXIS_0]MAX_OUTPUT
setp pid.1.maxoutput [AXIS_1]MAX_OUTPUT
setp pid.2.maxoutput [AXIS_2]MAX_OUTPUT

# TESTING AND TUNING VALUES
setp pid.2.maxoutput 0.01

# LADDER LOGIC!!!
#
# Classic ladder doesn't let you use meaningfull names, so this
# will be the magic decoder ring

# INPUTS to CL
# I0 = estop-ok-out, used to power up the servo amps (multi-step process)
linkps classicladder.0.in-00 estop-ok-out
# I1 = servo-enable, used to mask amp faults when not enabled
linkps classicladder.0.in-01 servo-enable
# I2 thru I4, amp running signal (FALSE when faulted OR disabled)
linkps classicladder.0.in-02 X-amp-running
linkps classicladder.0.in-03 Y-amp-running
linkps classicladder.0.in-04 Z-amp-running


# OUTPUTS from CL
# Q0 = AP1, first stage power up (applies power thru resitors)
linkps classicladder.0.out-00 AP1
# Q1 = AP2, second stage (bypasses resistors)
linkps classicladder.0.out-01 AP2
# Q2 thru Q4, amp faulted signal (ENABLED and NOT RUNNING)
linkps classicladder.0.out-02 X-amp-fault
linkps classicladder.0.out-03 Y-amp-fault
linkps classicladder.0.out-04 Z-amp-fault
# Q5 is motion enable (after chain)
linkps classicladder.0.out-05 motion-enable


# CL internals (not HAL data, just here for documentation
#
# T0 = delay from estop OK to AP1
# T1 = delay from AP1 to AP2
# T2 = delay to allow servo amps to respond to enable
# T3 = delay between AP2 close and motion enable

# B0 = delayed servo-enable, for fault masking
# B1 = delayed AP2 close, for motion enable