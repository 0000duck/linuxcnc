# HAL config file for simulated servo machine

# first load all the RT modules that will be needed
# kinematics
loadrt trivkins
# motion controller, get name and thread periods from ini file
loadrt [EMCMOT]EMCMOT base_period_nsec=[EMCMOT]BASE_PERIOD servo_period_nsec=[EMCMOT]SERVO_PERIOD traj_period_nsec=[EMCMOT]TRAJ_PERIOD key=[EMCMOT]SHMEM_KEY
# PID module, for three PID loops
loadrt pid num_chan=3
# 6 differentiators (for velocity and accel sigs),
loadrt ddt count=6
# three scale blocks (to simulate motor and leadscrew scaling),
loadrt scale count=3
# three lowpass filters (to simulate motor inertia), and nine
loadrt lowpass count=3
# window comparators (to simulate limit and home switches)
loadrt wcomp count=9

# simulated encoders
loadrt sim_encoder num_chan=3
# software encoder counters, 3 for feedback, 3 for actual axis pos
loadrt encoder num_chan=6

# add encoder counter and simulator functions to high speed thread
addf encoder.update-counters base-thread
addf sim-encoder.make-pulses base-thread

# add all required functions to servo thread
addf encoder.capture-position servo-thread
addf wcomp.0 servo-thread
addf wcomp.1 servo-thread
addf wcomp.2 servo-thread
addf wcomp.3 servo-thread
addf wcomp.4 servo-thread
addf wcomp.5 servo-thread
addf wcomp.6 servo-thread
addf wcomp.7 servo-thread
addf wcomp.8 servo-thread
addf motion-command-handler servo-thread
addf motion-controller servo-thread
addf pid.0.do-pid-calcs servo-thread
addf pid.1.do-pid-calcs servo-thread
addf pid.2.do-pid-calcs servo-thread
addf scale.0 servo-thread
addf scale.1 servo-thread
addf scale.2 servo-thread
addf lowpass.0 servo-thread
addf lowpass.1 servo-thread
addf lowpass.2 servo-thread
addf sim-encoder.update-speed servo-thread

# link the differentiator functions into the code
addf ddt.0 servo-thread
addf ddt.1 servo-thread
addf ddt.2 servo-thread
addf ddt.3 servo-thread
addf ddt.4 servo-thread
addf ddt.5 servo-thread

# create three position feedback signals
newsig Xpos-fb float
newsig Ypos-fb float
newsig Zpos-fb float

# get position feedback from encoder module
linksp Xpos-fb <= encoder.0.position
linksp Ypos-fb <= encoder.1.position
linksp Zpos-fb <= encoder.2.position

# set position feedback scaling
setp encoder.0.position-scale [AXIS_0]INPUT_SCALE
setp encoder.1.position-scale [AXIS_1]INPUT_SCALE
setp encoder.2.position-scale [AXIS_2]INPUT_SCALE

# connect position feedback to PID loop
linksp Xpos-fb => pid.0.feedback
linksp Ypos-fb => pid.1.feedback
linksp Zpos-fb => pid.2.feedback

# connect position feedback to motion module
linksp Xpos-fb => axis.0.motor-pos-fb
linksp Ypos-fb => axis.1.motor-pos-fb
linksp Zpos-fb => axis.2.motor-pos-fb

# connect encoder index-enables for homing on index
newsig Xindex-enable bit
newsig Yindex-enable bit
newsig Zindex-enable bit
linksp Xindex-enable encoder.0.index-enable
linksp Xindex-enable axis.0.index-enable
linksp Yindex-enable encoder.1.index-enable
linksp Yindex-enable axis.1.index-enable
linksp Zindex-enable encoder.2.index-enable
linksp Zindex-enable axis.2.index-enable

# create three position command signals
newsig Xpos-cmd float
newsig Ypos-cmd float
newsig Zpos-cmd float

# connect position commands to motion controller
linksp Xpos-cmd <= axis.0.motor-pos-cmd
linksp Ypos-cmd <= axis.1.motor-pos-cmd
linksp Zpos-cmd <= axis.2.motor-pos-cmd

# connect position commands to PID input
linksp Xpos-cmd => pid.0.command
linksp Ypos-cmd => pid.1.command
linksp Zpos-cmd => pid.2.command

# create bit signals to enable/disable the PID loops
newsig Xenable bit
newsig Yenable bit
newsig Zenable bit

# connect the signals to the motion controller
linksp Xenable <= axis.0.amp-enable-out
linksp Yenable <= axis.1.amp-enable-out
linksp Zenable <= axis.2.amp-enable-out

# connect the signals to the PID blocks
linksp Xenable => pid.0.enable
linksp Yenable => pid.1.enable
linksp Zenable => pid.2.enable

# create PID to "motor" output signals
newsig Xoutput float
newsig Youtput float
newsig Zoutput float

# connect output signals to output of PID loops
linksp Xoutput <= pid.0.output
linksp Youtput <= pid.1.output
linksp Zoutput <= pid.2.output

# connect output signals (in inches per sec) to
# scale blocks that translate to motor revs per sec
linksp Xoutput => scale.0.in
linksp Youtput => scale.1.in
linksp Zoutput => scale.2.in

# set scaling, number of motor revs needed to
# travel one inch
setp scale.0.gain [AXIS_0]DRIVE_RATIO
setp scale.1.gain [AXIS_1]DRIVE_RATIO
setp scale.2.gain [AXIS_2]DRIVE_RATIO

# motor speed commands
newsig Xmtr-cmd float
newsig Ymtr-cmd float
newsig Zmtr-cmd float

# motor speed command sigs come from scale blocks
linksp Xmtr-cmd <= scale.0.out
linksp Ymtr-cmd <= scale.1.out
linksp Zmtr-cmd <= scale.2.out

# motor speed commands go thru lowpass filters
# to simulate motor inertia
linksp Xmtr-cmd => lowpass.0.in
linksp Ymtr-cmd => lowpass.1.in
linksp Zmtr-cmd => lowpass.2.in

# set "inertia" here, probalby by trial and error
setp lowpass.0.gain 0.1
setp lowpass.1.gain 0.1
setp lowpass.2.gain 0.1

# "actual" motor speed signals
newsig Xmtr-spd float
newsig Ymtr-spd float
newsig Zmtr-spd float

# output of lowpass is simulated motor speed
linksp Xmtr-spd <= lowpass.0.out
linksp Ymtr-spd <= lowpass.1.out
linksp Zmtr-spd <= lowpass.2.out

# speed goes to simulated encoders
linksp Xmtr-spd => sim-encoder.0.speed
linksp Ymtr-spd => sim-encoder.1.speed
linksp Zmtr-spd => sim-encoder.2.speed

# set simulated encoder scaling
setp sim-encoder.0.ppr [AXIS_0]MOTOR_PPR
setp sim-encoder.1.ppr [AXIS_1]MOTOR_PPR
setp sim-encoder.2.ppr [AXIS_2]MOTOR_PPR

# simulated encoder output signals
newsig XphA bit
newsig XphB bit
newsig XphZ bit
newsig YphA bit
newsig YphB bit
newsig YphZ bit
newsig ZphA bit
newsig ZphB bit
newsig ZphZ bit

# connect them up
linksp XphA <= sim-encoder.0.phase-A
linksp XphA => encoder.0.phase-A
linksp XphB <= sim-encoder.0.phase-B
linksp XphB => encoder.0.phase-B
linksp XphZ <= sim-encoder.0.phase-Z
linksp XphZ => encoder.0.phase-Z
linksp YphA <= sim-encoder.1.phase-A
linksp YphA => encoder.1.phase-A
linksp YphB <= sim-encoder.1.phase-B
linksp YphB => encoder.1.phase-B
linksp YphZ <= sim-encoder.1.phase-Z
linksp YphZ => encoder.1.phase-Z
linksp ZphA <= sim-encoder.2.phase-A
linksp ZphA => encoder.2.phase-A
linksp ZphB <= sim-encoder.2.phase-B
linksp ZphB => encoder.2.phase-B
linksp ZphZ <= sim-encoder.2.phase-Z
linksp ZphZ => encoder.2.phase-Z

# set PID loop output limits to max velocity
setp pid.0.maxoutput [AXIS_0]MAX_VELOCITY
setp pid.1.maxoutput [AXIS_1]MAX_VELOCITY
setp pid.2.maxoutput [AXIS_2]MAX_VELOCITY

# set PID loop gains
# NOTE: eventually these will be non-zero values as
# needed to tune the performance of each axis.  The
# initial values shown here are extremely conservative
# to prevent unexpected behavior.  After this file 
# has been "executed" by halcmd, the gains can be
# interactively adjusted using commands like
# "halcmd setp pid.<channel>.Pgain <value>"
# Once the axis has been tuned to your satisfaction, 
# do "halcmd show param | grep pid" to get a listing 
# of the tuning parameters, and enter those values here.

# the values below come from the ini
setp pid.0.Pgain [AXIS_0]PGAIN
setp pid.0.Igain [AXIS_0]IGAIN
setp pid.0.Dgain [AXIS_0]DGAIN
setp pid.0.bias [AXIS_0]BIAS
setp pid.0.FF0 [AXIS_0]FF0
setp pid.0.FF1 [AXIS_0]FF1
# deadband should be just over 1 count
setp pid.0.deadband [AXIS_0]DEADBAND

setp pid.1.Pgain [AXIS_1]PGAIN
setp pid.1.Igain [AXIS_1]IGAIN
setp pid.1.Dgain [AXIS_1]DGAIN
setp pid.1.bias [AXIS_1]BIAS
setp pid.1.FF0 [AXIS_1]FF0
setp pid.1.FF1 [AXIS_1]FF1
# deadband should be just over 1 count
setp pid.1.deadband [AXIS_1]DEADBAND

setp pid.2.Pgain [AXIS_2]PGAIN
setp pid.2.Igain [AXIS_2]IGAIN
setp pid.2.Dgain [AXIS_2]DGAIN
setp pid.2.bias [AXIS_2]BIAS
setp pid.2.FF0 [AXIS_2]FF0
setp pid.2.FF1 [AXIS_2]FF1
# deadband should be just over 1 count
setp pid.2.deadband [AXIS_2]DEADBAND

# send the position commands thru differentiators to
# generate velocity and accel signals
# define the signals, and hook them up
newsig Xvel float
newsig Xacc float
linksp Xpos-cmd => ddt.0.in
linkps ddt.0.out => Xvel
linksp Xvel => ddt.1.in
linkps ddt.1.out => Xacc
newsig Yvel float
newsig Yacc float
linksp Ypos-cmd => ddt.2.in
linkps ddt.2.out => Yvel
linksp Yvel => ddt.3.in
linkps ddt.3.out => Yacc
newsig Zvel float
newsig Zacc float
linksp Zpos-cmd => ddt.4.in
linkps ddt.4.out => Zvel
linksp Zvel => ddt.5.in
linkps ddt.5.out => Zacc

# estop loopback
linkpp iocontrol.0.user-enable-out iocontrol.0.emc-enable-in

# create signals for tool loading loopback
linkpp iocontrol.0.tool-prepare iocontrol.0.tool-prepared
linkpp iocontrol.0.tool-change iocontrol.0.tool-changed

newsig xflt bit
linksp xflt axis.0.amp-fault-in
newsig yflt bit
linksp yflt axis.1.amp-fault-in
newsig zflt bit
linksp zflt axis.2.amp-fault-in

# signals for "actual" axis position
newsig Xaxis-pos float
newsig Yaxis-pos float
newsig Zaxis-pos float

# a second set of encoder counters keeps track of position
linksp XphA encoder.3.phase-A
linksp XphB encoder.3.phase-B
linksp YphA encoder.4.phase-A
linksp YphB encoder.4.phase-B
linksp ZphA encoder.5.phase-A
linksp ZphB encoder.5.phase-B

setp encoder.3.position-scale [AXIS_0]INPUT_SCALE
setp encoder.4.position-scale [AXIS_1]INPUT_SCALE
setp encoder.5.position-scale [AXIS_2]INPUT_SCALE

linksp Xaxis-pos encoder.3.position 
linksp Yaxis-pos encoder.4.position 
linksp Zaxis-pos encoder.5.position 

# connect "actual" position from encoders
# to window comparators
linksp Xaxis-pos => wcomp.0.in
linksp Xaxis-pos => wcomp.1.in
linksp Xaxis-pos => wcomp.2.in
linksp Yaxis-pos => wcomp.3.in
linksp Yaxis-pos => wcomp.4.in
linksp Yaxis-pos => wcomp.5.in
linksp Zaxis-pos => wcomp.6.in
linksp Zaxis-pos => wcomp.7.in
linksp Zaxis-pos => wcomp.8.in

# connect simulated switch outputs to motion controller
newsig Xminlim bit
newsig Xmaxlim  bit
newsig Xhome bit
linksp Xminlim <= wcomp.0.out
linksp Xminlim => axis.0.neg-lim-sw-in
linksp Xmaxlim <= wcomp.1.out
linksp Xmaxlim => axis.0.pos-lim-sw-in
linksp Xhome <= wcomp.2.out
linksp Xhome => axis.0.home-sw-in

newsig Yminlim bit
newsig Ymaxlim  bit
newsig Yhome bit
linksp Yminlim <= wcomp.3.out
linksp Yminlim => axis.1.neg-lim-sw-in
linksp Ymaxlim <= wcomp.4.out
linksp Ymaxlim => axis.1.pos-lim-sw-in
linksp Yhome <= wcomp.5.out
linksp Yhome => axis.1.home-sw-in

newsig Zminlim bit
newsig Zmaxlim  bit
newsig Zhome bit
linksp Zminlim <= wcomp.6.out
linksp Zminlim => axis.2.neg-lim-sw-in
linksp Zmaxlim <= wcomp.7.out
linksp Zmaxlim => axis.2.pos-lim-sw-in
linksp Zhome <= wcomp.8.out
linksp Zhome => axis.2.home-sw-in

# configure the points at which the simulated switches trip
# X axis first
# min limit switch
setp wcomp.0.max [AXIS_0]MIN_HARD_LIMIT
setp wcomp.0.min [AXIS_0]MIN_HARD_LIMIT_RELEASE
# max limit switch
setp wcomp.1.min [AXIS_0]MAX_HARD_LIMIT
setp wcomp.1.max [AXIS_0]MAX_HARD_LIMIT_RELEASE
# home switch
setp wcomp.2.min [AXIS_0]HOME_SW_MIN
setp wcomp.2.max [AXIS_0]HOME_SW_MAX

# Y axis
# min limit switch
setp wcomp.3.max [AXIS_1]MIN_HARD_LIMIT
setp wcomp.3.min [AXIS_1]MIN_HARD_LIMIT_RELEASE
# max limit switch
setp wcomp.4.min [AXIS_1]MAX_HARD_LIMIT
setp wcomp.4.max [AXIS_1]MAX_HARD_LIMIT_RELEASE
# home switch
setp wcomp.5.min [AXIS_1]HOME_SW_MIN
setp wcomp.5.max [AXIS_1]HOME_SW_MAX

# Z axis
# min limit switch
setp wcomp.6.max [AXIS_2]MIN_HARD_LIMIT
setp wcomp.6.min [AXIS_2]MIN_HARD_LIMIT_RELEASE
# max limit switch
setp wcomp.7.min [AXIS_2]MAX_HARD_LIMIT
setp wcomp.7.max [AXIS_2]MAX_HARD_LIMIT_RELEASE
# home switch
setp wcomp.8.min [AXIS_2]HOME_SW_MIN
setp wcomp.8.max [AXIS_2]HOME_SW_MAX
