#!/usr/bin/python
#
# Copyright 2014 Sebastian Kuzminsky
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# Debian source package configuration script for LinuxCNC.
#


import sys
import os
import glob
import re
import subprocess


#
# Important state variables.  These get built up as the program runs.
#

config = {}

# selected flavor
config['flavor'] = None

# packages we build-depend on
config['build-depends'] = set()

# Depends, Recommends, and Suggests for the main package (linuxcnc.deb)
config['depends'] = set()
config['recommends'] = set()
config['suggests'] = set()

# Depends for the dev package (linuxcnc-dev.deb)
config['dev-depends'] = set()

# arguments we want debian/rules to pass to src/configure
config['src/configure'] = set()

# arguments passed to debian/configure (us, now!) so we can rerun it via
# debian/rules if any of the .in files change
config['debian/configure'] = []


def usage():
    print """\
usage: debian/configure [OPTIONS]
configure debian source package
OPTIONS:
    --help, -h    This help.
    uspace, sim   Configure for uspace.
    -r, -a        Configure for the running realtime flavor.
"""


#
# This function inspects the config file of the specified installed kernel
# version.  If it finds a realtime flavor, it selects the detected flavor.
# If the specified kernel does not provide a realtime flavor, it prints an
# error message and exits.
#
def detect_installed_realtime_kernel(kernel_version, config):
    try:
        f = open("/boot/config-%s" % kernel_version)
    except IOError:
        print "Error: no kernel configuration found for %s" % kernel_version
        sys.exit(1)
    l = f.read(-1)
    f.close()

    config_ipipe = re.search('^CONFIG_IPIPE', l, re.MULTILINE)
    config_xeno = re.search('^CONFIG_XENO_', l, re.MULTILINE)
    config_rtpreempt = re.search('^CONFIG_PREEMPT_RT', l, re.MULTILINE)

    if config_ipipe and not config_xeno and not config_rtpreempt:
        config['flavor'] = 'rtai'

    elif config_rtpreempt and not config_ipipe and not config_xeno:
        config['flavor'] = 'uspace'

    elif config_ipipe and config_xeno and not config_rtpreempt:
        print "Error: kernel %s seems to be xenomai, which is not supported"
        sys.exit(1)

    else:
        print "Error: kernel %s has no known realtime extensions" % kernel_version
        sys.exit(1)


def detect_distro():
    # 'Ubuntu' or 'Debian'
    distributor_id = subprocess.Popen(["lsb_release", "--id", "--short"], stdout=subprocess.PIPE).communicate()[0]
    distributor_id = distributor_id[:-1]  # strip trailing newline

    # for example '12.04' or '7.3.0'
    release = subprocess.Popen(["lsb_release", "--short", "--release"], stdout=subprocess.PIPE).communicate()[0]
    release = release[:-1]  # strip trailing newline
    m = re.match('\d+\.\d+', release)
    if m == None:
        # Debian Testing has a non-numeric release, "testing"...
        release_f = 9999.9
    else:
        release_f = float(m.group(0))

    return (distributor_id, release, release_f)


def subst(infile, outfile, config):
    if type(infile) == list:
        infile = ' '.join(infile)

    try:
        retcode = subprocess.call(
            "sed -e 's`@BUILD_DEPENDS@`%s`g'" % ', '.join(config['build-depends'])
            + " -e 's`@DEPENDS@`%s`g'" % ', '.join(config['depends'])
            + " -e 's`@RECOMMENDS@`%s`g'" % ', '.join(config['recommends'])
            + " -e 's`@SUGGESTS@`%s`g'" % ', '.join(config['suggests'])
            + " -e 's`@DEV_DEPENDS@`%s`g'" % ', '.join(config['dev-depends'])
            + " -e 's`@SRC_CONFIGURE@`%s`g'" % ' '.join(config['src/configure'])
            + " -e 's`@DEBIAN_CONFIGURE@`%s`g'" % ' '.join(config['debian/configure'])
            + " -e 's`@PYTHON_VERSION@`%d.%d`g'" % (sys.version_info[0], sys.version_info[1])
            + " -e 's`@PYTHON_VERSION_NEXT@`%d.%d`g'" % (sys.version_info[0], 1 + sys.version_info[1])
            + " -e 's`@EXTRA_DIR@`%s`g'" % config['extra-dir']
            + " -e 's`@MAIN_PACKAGE_NAME@`%s`g'" % config['package-name']
            + " -e 's`@OTHER_MAIN_PACKAGE_NAME@`%s`g'" % config['other-package-name']
            + " -e 's`@MODULE_PATH@`%s`g'" % config['module-path']
            + " -e 's`@MODULE_EXT@`%s`g'" % config['module-extension']
            + " -e 's`@EXTRA_FILES@`%s`g'" % config['extra-files']
            + " %s > %s" % (infile, outfile),
            shell=True
        )
        if retcode < 0:
            print >>sys.stderr, "Child was terminated by signal", -retcode
    except OSError:
        print >>sys.stderr, "Failed to run sed!"


# save off the arguments the user just gave us
config['debian/configure'] = sys.argv[1:]


#
# some things are universal and don't depend on the flavor, distro, etc
#

# 'extra-dir' selects a directory (in debian/) to include in the main
# deb.  This one seems like we might want it to be different for different
# distros at some point.
config['extra-dir'] = 'extras'


if len(sys.argv) == 1 or sys.argv[1] == '-h' or sys.argv[1] == '--help':
    usage()
    sys.exit(0)

elif sys.argv[1] == 'uspace' or sys.argv[1] == 'sim':
    config['flavor'] = 'uspace'

elif sys.argv[1] == '-r' or sys.argv[1] == '-a':
    running_kernel_version = os.uname()[2]
    print "configuring for running realtime kernel %s" % running_kernel_version
    detect_installed_realtime_kernel(running_kernel_version, config)

elif sys.argv[1] == '--all':
    # detect_available_realtime_kernels
    print "Error: Not implemented yet!"
    sys.exit(1)

else:
    print "Error: invalid command line"
    usage()
    sys.exit(1)


(distributor_id, release, release_f) = detect_distro()
print "configuring for %s %s" % (distributor_id, release)


# configure the tcl/tk version
# Lucid's default tcl/tk version is 8.4, we need to override it to 8.5
# all other distros can use the default version
if distributor_id == 'Ubuntu' and release == '10.04':
    config['build-depends'].add('tcl8.5-dev')
    config['build-depends'].add('tk8.5-dev')
    config['depends'].add('tcl8.5')
    config['depends'].add('tk8.5')
else:
    config['build-depends'].add('tcl-dev')
    config['build-depends'].add('tk-dev')
    config['depends'].add('tcl')
    config['depends'].add('tk')


# configure the lsmod/insmod/rmmod package
# this is kmod on modern distros and module-init-tools.deb on older ones
if distributor_id == 'Ubuntu' and release_f < 13.04:
    config['build-depends'].add('module-init-tools')
elif distributor_id == 'Debian' and release_f < 7:
    config['build-depends'].add('module-init-tools')
else:
    config['build-depends'].add('kmod')


# older distros have libgnomeprintui, newer ones do not
if distributor_id == 'Ubuntu' and release_f < 14.04:
    config['build-depends'].add('libgnomeprintui2.2-dev')
elif distributor_id == 'Debian' and release_f < 8:
    config['build-depends'].add('libgnomeprintui2.2-dev')


if config['flavor'] == 'uspace':
    config['package-name'] = 'linuxcnc-uspace'
    config['other-package-name'] = 'linuxcnc'
    config['build-depends'].add('libudev-dev')
    config['recommends'].add('linux-image-rt-amd64 [linux-amd64]')
    config['recommends'].add('linux-image-rt-686-pae [linux-i386]')
    config['src/configure'].add('--with-realtime=uspace')
    config['module-path'] = 'usr/lib/linuxcnc/modules'
    config['module-extension'] = '.so'
    config['extra-files'] = 'usr/bin/rtapi_app'

elif config['flavor'] == 'rtai':
    config['package-name'] = 'linuxcnc'
    config['other-package-name'] = 'linuxcnc-uspace'
    config['build-depends'].add("linux-headers-%s" % running_kernel_version)
    config['build-depends'].add("rtai-modules-%s" % running_kernel_version)
    config['depends'].add("linux-image-%s" % running_kernel_version)
    config['depends'].add("rtai-modules-%s" % running_kernel_version)
    config['dev-depends'].add("linux-headers-%s" % running_kernel_version)
    config['src/configure'].add('--with-realtime=rtai')
    config['module-path'] = 'usr/realtime-%s/modules/linuxcnc' % running_kernel_version
    config['module-extension'] = '.ko'
    config['extra-files'] = 'usr/bin/linuxcnc_module_helper'

else:
    print "Error: unknown flavor %s" % config['flavor']
    sys.exit(1)

# report the selected flavor
print "selected flavor: " + config['flavor']


#
# All done configuring!  Time to start creating debian files!
#


# make the control file
subst('control.in', 'control', config)

# make the rules file
subst('rules.in', 'rules', config)
mode = os.stat('rules').st_mode
mode |= 0111
os.chmod('rules', mode)

# make linuxcnc.files
outfile = config['package-name'] + '.files'
files = ['linuxcnc.files.in']
if os.access(config['extra-dir'] + "/linuxcnc.files", os.R_OK):
    files.append(config['extra-dir'] + "/linuxcnc.files")
if config['flavor'] == 'rtai':
    files.append("drivers.files.in")
subst(files, outfile, config)

# make linuxcnc-dev.files
linuxcnc_dev_files = config['package-name'] + '-dev.files'
subst('linuxcnc-dev.files.in', linuxcnc_dev_files, config)
if config['flavor'] == "rtai":
    f = open(linuxcnc_dev_files, 'a')
    f.write(config['module-path'] + '/Module.symvers')
    f.close()

# make linuxcnc-doc-*.files
docs_packages = [
    'linuxcnc-doc-en',
    'linuxcnc-doc-fr',
    'linuxcnc-doc-es'
]
for p in docs_packages:
    outfile = p + '.files'
    infiles = [ p + '.files.in' ]
    extra_doc_file = config['extra-dir'] + '/' + p + ".files"
    if os.access(extra_doc_file, os.R_OK):
        infiles.append(extra_doc_file)
    subst(infiles, outfile, config)

# FIXME:
# rm -f ../build-stamp
