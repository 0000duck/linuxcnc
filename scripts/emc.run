#!/bin/bash
# usage: emc.run [options] [<ini-file>]
#
# options:
#     -v = echos script commands to screen for debugging
#
# if <ini-file> not specified, uses EMC2_DIR/configs/emc.ini
# if path specified, looks there, else looks in $EMC2_DIR/configs
#

# change to the EMC2 root directory
# get name and (possibly relative) path of this script
SCRIPT=`which $0 | grep $0`
# extract the name of the script
SCRIPT_NAME=`echo $SCRIPT | sed s#\^.\*/##`
# delete the name to get the path
SCRIPT_DIR=`echo $SCRIPT | sed s/$SCRIPT_NAME//`
# the path might be relative - convert to an absolute path
SCRIPT_DIR=$(cd $SCRIPT_DIR ; pwd -P)
# strip the "/scripts" part to get the root of the
# EMC2 directory tree
EMC2_DIR=`echo $SCRIPT_DIR | sed s#/scripts## `
# change to the EMC2 root
cd $EMC2_DIR

# bit bucket file
ERROR_OUT_FILE=/dev/null
# strip and process command line options
while echo $1 | grep ^- >/dev/null ; do
    # found an option
    OPTION=$1
    # strip it
    shift
    # process options
    if [ $OPTION = "-v" ] ; then
        # enable echoing of script
        set -x;
        ERROR_OUT_FILE=/dev/tty
    else
        echo "Unknown option '$OPTION'"
    fi
done

# look for ini file
INIFILE=
if [ ! -n "$1" ] ; then
    INIFILE=$EMC2_DIR/configs/emc.ini
elif echo $1 | grep / >/dev/null ; then
    INIFILE=$1
else
    INIFILE=$EMC2_DIR/configs/$1
fi
if [ ! -f $INIFILE ] ; then
    echo "Could not find ini file '$INIFILE'"
    exit -1
fi
echo INIFILE=$INIFILE

#DEBUGGER=gdb
#if [ -f ${HOME}/.debugger_name ] ; then
#    DEBUGGER=`cat ${HOME}/.debugger_name | head -n 1`
#fi

# check for root privliges - hope to remove the need for this later
if [ `whoami` != root ] ; then
    echo "Sorry, you must be root to run EMC"
    exit -1
fi

# Find out where the inivar program is
if [ -x $EMC2_DIR/bin/inivar ] ; then
    INIVAR=$EMC2_DIR/bin/inivar
else
    echo "Can't locate inivar program - should be in $EMC2_DIR/bin/inivar"
    exit -1
fi
echo INIVAR=$INIVAR

# Find out where insmod and rmmod are
if [ -x /sbin/insmod ] ; then
    INSMOD=/sbin/insmod
else
    echo "Can't locate insmod program - should be in /sbin/insmod"
    exit -1
fi
if [ -x /sbin/rmmod ] ; then
    RMMOD=/sbin/rmmod
else
    echo "Can't locate rmmod program - should be in /sbin/rmmod"
    exit -1
fi
echo INSMOD=$INSMOD
echo RMMOD=$RMMOD

# get name of RS274NGC parameter file
# question - why do we do this now?
RS274NGC_PARAMFILE=`$INIVAR -ini $INIFILE -var PARAMETER_FILE -sec RS274NGC`
if [ ! -n "$RS274NGC_PARAMFILE" ] ; then
    echo "Can't find variable PARAMETER_FILE in section [RS274NGC] of file $INIFILE."
    exit -1
fi
echo RS274NGC_PARAMFILE=$RS274NGC_PARAMFILE

# get emcmot information
EMCMOT=`$INIVAR -ini $INIFILE -var EMCMOT -sec EMCMOT`
if [ ! -n "$EMCMOT" ] ; then
    echo "Can't find variable EMCMOT in section [EMCMOT] of file $INIFILE."
    exit -1
fi
echo EMCMOT=$EMCMOT

# get emcio information
EMCIO=`$INIVAR -ini $INIFILE -var EMCIO -sec EMCIO`
if [ ! -n "$EMCIO" ] ; then
    echo "Can't find variable EMCIO in section [EMCIO] of file $INIFILE."
    exit -1
fi
echo EMCIO=$EMCIO

# get emctask information
EMCTASK=`$INIVAR -ini $INIFILE -var TASK -sec TASK`
if [ ! -n "$EMCTASK" ] ; then
    echo "Can't find variable TASK in section [TASK] of file $INIFILE."
    exit -1
fi
echo EMCTASK=$EMCTASK

# get emcserver information
EMCSERVER=`$INIVAR -ini $INIFILE -var EMCSERVER -sec EMCSERVER`
# no check needed - if nothing found, nothing will run
echo EMCSERVER=$EMCSERVER

# get emcstrip information
EMSTRIP=`$INIVAR -ini $INIFILE -var EMCSTRIP -sec EMCSTRIP`
# if none found, it just won't run... but if found, check for options
if [ -n "$EMCSTRIP" ] ; then
    EMCSTRIP_OPTIONS=`$INIVAR -ini $INIFILE -var OPTIONS -sec EMCSTRIP`
fi
echo EMCSTRIP=$EMCSTRIP
echo EMCSTRIP_OPTIONS=$EMCSTRIP_OPTIONS

# get display information
EMCDISPLAY=`$INIVAR -ini $INIFILE -var DISPLAY -sec DISPLAY`
if [ ! -n "$EMCDISPLAY" ] ; then
    echo "Can't find variable DISPLAY in section [DISPLAY] of file $INIFILE.";
fi
echo EMCDISPLAY=$EMCDISPLAY

# get NML config information
NMLFILE=`$INIVAR -ini $INIFILE -var NML_FILE -sec EMC`
if [ ! -n "$NMLFILE" ] ; then
    echo "Can't find variable NML_FILE in section [EMC] of file $INIFILE.";
fi
echo NMLFILE=$NMLFILE

# Name of lock file to check for that signifies that EMC is up,
# to prevent multiple copies of controller
LOCKFILE=/tmp/emc.lock

# 'STARTED' is flag that's set only if we create lock file, so
# if we get ^C we won't delete a previous lock file
set STARTED = 0

# Check for lock file
if [ -f $LOCKFILE ]; then
  echo -n "EMC is running -- restart it? [y/n] "
  read input
  case $input in
    y|Y)
      echo Cleaning up old emc...
    ;;
    *)
      echo Not starting new emc
      exit 0
    ;;
  esac
else
  echo Starting emc...
fi

# Create the lock file
touch $LOCKFILE

# Mark that we created it
STARTED=1

# DON'T KNOW IF WE NEED THESE YET....
#
bccmd=none
#if [ -x /usr/bin/bc ] ; then
#    bccmd=/usr/bin/bc ;
#fi
#if [ -x /bin/bc ] ; then
#    bccmd=/bin/bc ;
#fi
pidofcmd=none
#if [ -x /usr/bin/pidof ] ; then
#    pidofcmd=/usr/bin/pidof ;
#fi
#if [ -x /bin/pidof ] ; then
#    pidofcmd=/bin/pidof ;
#fi
#if [ -x /sbin/pidof ] ; then
#    pidofcmd=/sbin/pidof ;
#fi
#

# DON'T KNOW IF WE NEED THIS YET
#
#tasktokill=""
#killtasktimeout=10
#
#function killtaskwithtimeout () {
#
#    if [ "${PLATBASE}" = "sunos" ] ; then
#	shorttasktokillname=`echo $tasktokill | awk  '{printf("%8.8s",$1);}'`
#	pids=`ps | grep $shorttasktokillname | awk '{printf("%d ",$1);}'`
#	kill -INT $pids
#    else
#	killall -INT $tasktokill 2> ${ERROR_OUT_FILE}
#
#	if [ $bccmd != "none" -a $pidofcmd != "none" ] ; then
#	    time=`date +%s`
#	    deadline=`echo $time+ $killtasktimeout | $bccmd`
#	    while $pidofcmd $tasktokill > /dev/null ; do
#		if [ `date +%s` -gt $deadline ] ; then
#		    echo "Timedout waiting for $tasktokill to die. Upgrading to -KILL"
#		    break;
#		fi
#		echo Waiting for $tasktokill to die . . .
#		killall -INT $tasktokill 2> ${ERROR_OUT_FILE}
#		sleep 1
#	    done
#	    time=`date +%s`
#	    deadline=`echo $time+ $killtasktimeout | $bccmd`
#	    while $pidofcmd $tasktokill > /dev/null ; do
#		if [ `date +%s` -gt $deadline ] ; then
#		    echo Timedout waiting for $tasktokill to die.
#		    break;
#		fi
#		echo Waiting for $tasktokill to die . . .
#		killall -KILL $tasktokill 2> ${ERROR_OUT_FILE}
#		sleep 1
#	    done
#	fi
#  fi
#}


# DON'T KNOW WHAT THIS IS FOR
#
# ipckeys=`grep SHMEM $NMLFILE | gawk '{printf("%x ",$10);}'`


# DON'T KNOW IF WE NEED THIS YET
#
## define the cleanup function
#function cleanup() {
## Kill any displays lying around
#  case $display in
#    xemc|yemc|emcpanel|keystick)
#      tasktokill=$display
#      killtaskwithtimeout
#    ;;
#    tkemc)
#      tasktokill=emcsh
#      killtaskwithtimeout
#    ;;
#    *)
#      tasktokill=$display
#      killtaskwithtimeout
#    ;;
#  esac
#
## Kill any emcservers lying around
#  case $emcserver in
#    emcsvr)
#      tasktokill=$emcserver
#      killtaskwithtimeout
#    ;;
#    "")
#    ;;
#    *)
#      tasktokill=$emcserver
#      killtaskwithtimeout
#    ;;
#  esac
##
## Kill any emcstrips lying around
#  case $emcstrip in
#    emcstripchart)
#      tasktokill=$emcstrip
##      killtaskwithtimeout
#    ;;
#    "")
#    ;;
#    *)
#      tasktokill=$emcstrip
#      killtaskwithtimeout
#    ;;
#  esac
#
## Kill any emctasks lying around
#  case $emctask in
#    bridgeporttask|minimilltask)
#      tasktokill=$emctask
#      killtaskwithtimeout
#    ;;
#    *)
#      tasktokill=$emctask
#      killtaskwithtimeout
#    ;;
#  esac
#
## Kill any emcios lying around
#  case $emcio in
#    bridgeportio|minimillio|simio|ppmcio)
#      tasktokill=$emcio
#      killtaskwithtimeout
#    ;;
#    tkio)
#      tasktokill=iosh
#      killtaskwithtimeout
#    ;;
#    *)
#      tasktokill=$emcio
#      killtaskwithtimeout
#    ;;
#  esac
#
## Kill any emcmots lying around
#  case $emcmot in
#    *.o)
#      if /sbin/lsmod | grep $(echo $emcmot | sed s/\\.o//g) >/dev/null
#2>/dev/null ; then 	echo Removing module  $(echo $emcmot | sed s/\\.o//g)
#	/sbin/rmmod $(echo $emcmot | sed s/\\.o//g)
#      fi
#    ;;
#    *)
#      tasktokill=$emcmot
#      killtaskwithtimeout
#    ;;
#  esac
#
## remove the lock file, if we create it
#  if [ "$STARTED" = "1" ]; then
#    \rm -f $LOCKFILE
#  fi
#
## Check to see if the inifile was changed. If not delete the unnecessary
## backup.
#
#
#  if [ -f $INIFILE.$DATESTRING ] ; then
#    if diff $INIFILE $INIFILE.$DATESTRING > /dev/null ; then
#	echo $INIFILE was not changed.
#	\rm $INIFILE.$DATESTRING
#    else
#	echo $INIFILE was changed.
#	diff $INIFILE $INIFILE.$DATESTRING
#	diff $INIFILE $INIFILE.$DATESTRING >$INIFILE.$DATESTRING.diff
#	echo $INIFILE differences saved to $INIFILE.$DATESTRING.diff
#	\rm $INIFILE.$DATESTRING;
#    fi
#  else
#    DATESTRING=`date +%Y%m%d%H%M%S`
#    cp $INIFILE $INIFILE.$DATESTRING
#  fi
#
#
#    if [ -n "$RS274NGC_PARAMFILE" ] ; then
#	if [ -f $RS274NGC_PARAMFILE.$DATESTRING ] ; then
#	    if diff $RS274NGC_PARAMFILE $RS274NGC_PARAMFILE.$DATESTRING > /dev/null ; then
#		echo $RS274NGC_PARAMFILE was not changed.
#		\rm $RS274NGC_PARAMFILE.$DATESTRING
#	    else
#		echo $RS274NGC_PARAMFILE was changed.
#		diff $RS274NGC_PARAMFILE $RS274NGC_PARAMFILE.$DATESTRING
#		diff $RS274NGC_PARAMFILE $RS274NGC_PARAMFILE.$DATESTRING >$RS274NGC_PARAMFILE.$DATESTRING.diff
#		echo $RS274NGC_PARAMFILE differences saved to $RS274NGC_PARAMFILE.$DATESTRING.diff
#		\rm $RS274NGC_PARAMFILE.$DATESTRING;
#	    fi
#	else
#	    cp $RS274NGC_PARAMFILE $RS274NGC_PARAMFILE.$DATESTRING
#	fi
#   fi
#
#    # Delete sharedmemory segments and semaphores
#    for key in $ipckeys ; do
#	id=`ipcs -m | grep $key | gawk '{print $2}'`
#	if [ ${#id} -gt 1 ] ; then
#	    echo "Removing shared memory " $id
#	    if [ "${PLATBASE}" = "sunos" ] ; then
#		ipcrm -m $id
#	    else
#		ipcrm shm $id
#	    fi
#	fi
#	id=`ipcs -s | grep $key | gawk '{print $2}'`
#	if [ ${#id} -gt 1 ] ; then
#	    echo "Removing semaphore" $id
#	    if [ "${PLATBASE}" = "sunos" ] ; then
#		ipcrm -s $id
#	    else
#		ipcrm sem $id
#	    fi
#	fi
#    done
#
#    if [ -z "$PURE_SIMULATION" ] ; then
#	if [ -x ./remove_realtime_base ] ; then
#	    ./remove_realtime_base
#	    sleep 1
#	fi
#    fi
#}
#

# NEED TO DO THIS EVENTUALLY

# call cleanup function
# cleanup

# and trap ^C so that it's called if user interrupts script
# trap 'cleanup ; exit 0' SIGINT

# SKIP THE POPUP FOR NOW
#
## pop up intro graphic
#img=`$INIVAR -ini $INIFILE -var INTRO_GRAPHIC -sec DISPLAY`
#imgtime=`$INIVAR -ini $INIFILE -var INTRO_TIME -sec DISPLAY`
#if [ "$imgtime" = "" ] ; then
#  imgtime=5
#fi
#if [ "$img" != "" ] ; then
#  if [ -x $EMC2_DIR/bin/popimage ] ; then
#    $EMC2_DIR/bin/popimage $img $imgtime &
#  fi
#fi

# WOW! IT'S FINALLY TIME TO START LOADING EMC!!!

echo "Starting realtime system"
if $EMC2_DIR/scripts/realtime start ; then
    echo "Realtime system started"
else
    echo "Realtime system did not load"
    exit -1
fi

# EMC2 DOES THIS DIFFERENTLY
#
## run emcmot in background
#echo -n "Starting EMC MOTION PROGRAM -- $emcmot..."
#case $emcmot in
#  stgmod.o|stg2mod.o|stg8mod.o|stg_v2_8axis.o|newstgmod.o|vtiisamod.o|vtipcimod.o|ppmcmod.o|ppmcmod8.o|univstepmod.o)
## STG modules need SHMEM_BASE_ADDRESS and IO_BASE_ADDRESS
#    shmem_base_address=`$INIVAR -ini $INIFILE -var SHMEM_BASE_ADDRESS -sec EMCMOT`
#    if [ "$shmem_base_address" = "" ]; then
#      echo "can't find SHMEM_BASE_ADDRESS in $INIFILE"
#      cleanup
#      exit 1
#    fi
#    stg_base_address=`$INIVAR -ini $INIFILE -var IO_BASE_ADDRESS -sec EMCMOT`
#    if [ "$stg_base_address" = "" ]; then
#      echo "can't find IO_BASE_ADDRESS in $INIFILE"
#      exit 1
#    fi
#    optargs=""
#    motion_io_address=`$INIVAR -ini $INIFILE -var MOTION_IO_ADDRESS -sec EMCMOT`
#    if [ "$motion_io_address" != "" ]; then
#      optargs="$optargs MOTION_IO_ADDRESS=$motion_io_address"
#    fi
#    if ! /sbin/insmod -f plat/$emcmot_plat/lib/$emcmot SHMEM_BASE_ADDRESS=$shmem_base_address IO_BASE_ADDRESS=$stg_base_address $optargs; then
#      echo "can't install it"
#      cleanup
#      exit 1
#    else
#      echo "done"
#    fi
#  ;;
#  steppermod.o|freqmod.o|smdromod.o)
# stepper modules need SHMEM_BASE_ADDRESS and IO_BASE_ADDRESS
#    shmem_base_address=`$INIVAR -ini $INIFILE -var SHMEM_BASE_ADDRESS -sec EMCMOT`
#    if [ "$shmem_base_address" = "" ]; then
#      echo "can't find SHMEM_BASE_ADDRESS in $INIFILE"
#      cleanup
#      exit 1
#    fi
#    parport_io_address=`$INIVAR -ini $INIFILE -var IO_BASE_ADDRESS -sec EMCMOT`
#    if [ "$parport_io_address" = "" ]; then
#      echo "can't find IO_BASE_ADDRESS in $INIFILE"
#      cleanup
#      exit 1
#    fi
#    optargs=""
#    period=`$INIVAR -ini $INIFILE -var PERIOD -sec EMCMOT`
#    if [ "$period" != "" ]; then
#      period=$(echo $period 1000000000 \* 1 / p c | dc)
#      optargs="$optargs PERIOD=$period"
#    fi
#    steppingtype=`$INIVAR -ini $INIFILE -var STEPPING_TYPE -sec EMCMOT`
#    if [ "$steppingtype" != "" ]; then
#      optargs="$optargs STEPPING_TYPE=$steppingtype"
#    fi
#    motion_io_address=`$INIVAR -ini $INIFILE -var MOTION_IO_ADDRESS -sec EMCMOT`
#    if [ "$motion_io_address" != "" ]; then
#      optargs="$optargs MOTION_IO_ADDRESS=$motion_io_address"
#    fi
#    dro_base_address=`$INIVAR -ini $INIFILE -var DRO_BASE_ADDRESS -sec EMCMOT`
#    if [ "$dro_base_address" != "" ]; then
#      optargs="$optargs DRO_BASE_ADDRESS=$dro_base_address"
#    fi
#    if ! /sbin/insmod -f plat/$emcmot_plat/lib/$emcmot SHMEM_BASE_ADDRESS=$shmem_base_address IO_BASE_ADDRESS=$parport_io_address $optargs; then
#      echo "can't install it"
#      cleanup
#      exit 1
#    else
#      echo "done"
#    fi
#  ;;
#  minitetra.o)
## minitetra module needs SHMEM_BASE_ADDRESS and IO_BASE_ADDRESS
#    shmem_base_address=`$INIVAR -ini $INIFILE -var SHMEM_BASE_ADDRESS -sec EMCMOT`
#    if [ "$shmem_base_address" = "" ]; then
#      echo "can't find SHMEM_BASE_ADDRESS in $INIFILE"
#      cleanup
#      exit 1
#    fi
#    parport_io_address=`$INIVAR -ini $INIFILE -var IO_BASE_ADDRESS -sec EMCMOT`
#    if [ "$parport_io_address" = "" ]; then
#      echo "can't find IO_BASE_ADDRESS in $INIFILE"
#      cleanup
#      exit 1
#    fi
#    optargs=""
#    period=`$INIVAR -ini $INIFILE -var PERIOD -sec EMCMOT`
#    if [ "$period" != "" ]; then
#      period=$(echo $period 1000000000 \* 1 / p c | dc)
#      optargs="$optargs PERIOD=$period"
#    fi
#    steppingtype=`$INIVAR -ini $INIFILE -var STEPPING_TYPE -sec EMCMOT`
#    if [ "$steppingtype" != "" ]; then
#      optargs="$optargs STEPPING_TYPE=$steppingtype"
#    fi
#    motion_io_address=`$INIVAR -ini $INIFILE -var MOTION_IO_ADDRESS -sec EMCMOT`
#    if [ "$motion_io_address" != "" ]; then
#      optargs="$optargs MOTION_IO_ADDRESS=$motion_io_address"
#    fi
#    if ! /sbin/insmod -f plat/$emcmot_plat/lib/$emcmot SHMEM_BASE_ADDRESS=$shmem_base_address IO_BASE_ADDRESS=$parport_io_address $optargs; then
#      echo "can't install it"
#      cleanup
#      exit 1
#    else
#      echo "done"
#    fi
#  ;;
#  simmod.o)
## Real-time simulation  module needs inisim to be run.
#    if ! /sbin/insmod -f plat/$emcmot_plat/lib/$emcmot; then
#      echo "can't install it"
#      cleanup
#      exit 1
#    else
#      echo Running inisim to send INIFILE simulation parameters to the real-time simulator.
#      plat/$PLAT/bin/inisim -ini $INIFILE
#      echo "done"
#    fi
#  ;;
#  emcmotsim)
#    if [ ! -x plat/$emcmot_plat/bin/$emcmot ] ; then
#      echo "can't run $emcmot program"
#      echo "The file plat/$emcmot_plat/bin/$emcmot does not exist or is not executable."
#      cleanup
#      exit 1
#    fi
#    if [ -f ${HOME}/.debug_emcmot ] ; then
#        xterm -sb -sl 1000 -e ${DEBUGGER} plat/$emcmot_plat/bin/$emcmot  &
#        echo "Press ENTER when the $emcmot is running in the debugger."
#        read foo
#    else
#        plat/$emcmot_plat/bin/$emcmot -ini $INIFILE &
#    fi
#    echo "done"
#  ;;
#  emcmotsim.tc)
#    if [ ! -x plat/$emcmot_plat/bin/$emcmot ] ; then
#      echo "can't run $emcmot program"
#      echo "The file plat/$emcmot_plat/bin/$emcmot does not exist or is not executable."
#      cleanup
#      exit 1
#    fi
#    if [ -f ${HOME}/.debug_emcmot ] ; then
#        xterm -sb -sl 1000 -e ${DEBUGGER} plat/$emcmot_plat/bin/$emcmot  &
#        echo "Press ENTER when the $emcmot is running in the debugger."
#        read foo
#    else
#        plat/$emcmot_plat/bin/$emcmot -ini $INIFILE &
#    fi
#    sleep 20
#    echo "done"
#  ;;
#  genhexsim)
#    if [ ! -x plat/$emcmot_plat/bin/$emcmot ] ; then
#      echo "can't run $emcmot program"
#      echo "The file plat/$emcmot_plat/bin/$emcmot does not exist or is not executable."
#      cleanup
#      exit 1
#    fi
#    if [ -f ${HOME}/.debug_emcmot ] ; then
#        xterm -sb -sl 1000 -e ${DEBUGGER} plat/$emcmot_plat/bin/$emcmot  &
#        echo "Press ENTER when the $emcmot is running in the debugger."
#        read foo
#    else
#        plat/$emcmot_plat/bin/$emcmot -ini $INIFILE -noforward &
#    fi
#    echo "done"
#  ;;
#  *.o)
#    # Unknown .o assume its a realtime module that
#    # may or may not need SHMEM_BASE_ADDRESS, IO_BASE_ADDRESS, IO_BASE_ADDRESS, PERIOD
#    optargs=""
#    period=`$INIVAR -ini $INIFILE -var PERIOD -sec EMCMOT`
#    if [ "$period" != "" ]; then
#      period=$(echo $period 1000000000 \* 1 / p c | dc)
#      optargs="$optargs PERIOD=$period"
#    fi
#    shmem_base_address=`$INIVAR -ini $INIFILE -var SHMEM_BASE_ADDRESS -sec EMCMOT`
#    if [ "$shmem_base_address" != "" ]; then
#      pcount=`/sbin/modinfo -p $emcmot | grep IO_BASE_ADDRESS | wc -l`
#      if [ $pcount -eq 1 ] ; then
#	optargs="$optargs SHMEM_BASE_ADDRESS=$shmem_base_address"
#      fi
#    fi
#    stg_base_address=`$INIVAR -ini $INIFILE -var IO_BASE_ADDRESS -sec EMCMOT`
#    if [ "$stg_base_address" != "" ]; then
#      pcount=`/sbin/modinfo -p $emcmot | grep IO_BASE_ADDRESS | wc -l`
#      if [ $pcount -eq 1 ] ; then
#	optargs="$optargs IO_BASE_ADDRESS=$stg_base_address"
#      fi
#    fi
#    parport_io_address=`$INIVAR -ini $INIFILE -var IO_BASE_ADDRESS -sec EMCMOT`
#    if [ "$parport_io_address" != "" ]; then
#      pcount=`/sbin/modinfo -p $emcmot | grep IO_BASE_ADDRESS | wc -l`
#      if [ $pcount  -eq 1 ] ; then
#	optargs="$optargs IO_BASE_ADDRESS=$parport_io_address"
#      fi
#    fi
#    motion_io_address=`$INIVAR -ini $INIFILE -var MOTION_IO_ADDRESS -sec EMCMOT`
#    if [ "$motion_io_address" != "" ]; then
#      pcount=`/sbin/modinfo -p $emcmot | grep MOTION_IO_ADDRESS | wc -l`
#      if [ $pcount  -eq 1 ] ; then
#	optargs="$optargs MOTION_IO_ADDRESS=$motion_io_address"
#      fi
#    fi
#    echo /sbin/insmod -f plat/$emcmot_plat/lib/$emcmot $optargs
#    if ! /sbin/insmod -f plat/$emcmot_plat/lib/$emcmot $optargs; then
#      echo "can't install it"
#      cleanup
#      exit 1
#    else
#      echo "done"
#    fi
#  ;;
#  *)
#    # Unknown but not .o so assume it is a non-realtime executable.
#    if [ ! -x plat/$emcmot_plat/bin/$emcmot ] ; then
#      echo "can't run $emcmot program"
#      echo "The file plat/$emcmot_plat/bin/$emcmot does not exist or is not executable."
#      cleanup
#      exit 1
#    fi
#   if [ -f ${HOME}/.debug_emcmot ] ; then
#        xterm -sb -sl 1000 -e ${DEBUGGER} plat/$emcmot_plat/bin/$emcmot  &
#        echo "Press ENTER when the $emcmot is running in the debugger."
#        read foo
#    else
#        plat/$emcmot_plat/bin/$emcmot -ini $INIFILE &
#    fi
#    echo "done"
#  ;;
#esac
#





# Run emcmot in the background
echo -n "Starting EMC MOTION PROGRAM --  $EMCMOT..."
if [ ! "$EMCMOT" = "motmod.o" ] ; then
    echo "Can't run $EMCMOT"
    echo "EMC2 can ONLY run motmod.o as it's motion controller!"
#    cleanup
    exit 1
fi
if [ ! -f $EMC2_DIR/rtlib/$EMCMOT ] ; then
    echo "Can't find motion controller $EMC2_DIR/rtlib/$EMCMOT"
#    cleanup
    exit 1
fi
# get thread periods
BASE_PERIOD_SEC=`$INIVAR -ini $INIFILE -var BASE_PERIOD -sec EMCMOT`
if [ ! -n "$BASE_PERIOD_SEC" ] ; then
    echo "Can't find variable BASE_PERIOD in section [EMCMOT] of file $INIFILE."
#    cleanup
    exit -1
fi
BASE_PERIOD_NSEC=`echo $BASE_PERIOD_SEC | awk -- '{printf "%d\n", $1*1000000000}'`
SERVO_PERIOD_SEC=`$INIVAR -ini $INIFILE -var SERVO_PERIOD -sec EMCMOT`
if [ ! -n "$SERVO_PERIOD_SEC" ] ; then
    echo "Can't find variable SERVO_PERIOD in section [EMCMOT] of file $INIFILE."
#    cleanup
    exit -1
fi
SERVO_PERIOD_NSEC=`echo $SERVO_PERIOD_SEC | awk -- '{printf "%d\n", $1*1000000000}'`
TRAJ_PERIOD_SEC=`$INIVAR -ini $INIFILE -var TRAJ_PERIOD -sec EMCMOT`
if [ ! -n "$TRAJ_PERIOD_SEC" ] ; then
    echo "Can't find variable TRAJ_PERIOD in section [EMCMOT] of file $INIFILE."
#    cleanup
    exit -1
fi
TRAJ_PERIOD_NSEC=`echo $TRAJ_PERIOD_SEC | awk -- '{printf "%d\n", $1*1000000000}'`
# load the motion module

# DON'T ACTUALLY LOAD IT!
#if ! $INSMOD $EMC2_DIR/rtlib/$EMCMOT base_period=$BASE_PERIOD_NSEC servo_period=$SERVO_PERIOD_NSEC traj_period=$TRAJ_PERIOD_NSEC ; then
#    echo "Motion module $EMCMOT did not load..."
#    echo "check system log for error messages"
##    cleanup
#    exit -1
#fi
echo "loaded."


# HAL realtime module loading
MODNUM=1
MODNAME=`$INIVAR -ini $INIFILE -var RTMOD$MODNUM -sec HAL`
while [ -n "$MODNAME" ] ; do
    MODCFG=`$INIVAR -ini $INIFILE -var RTMODCFG$MODNUM -sec HAL`
    echo "Starting realtime HAL module $MODNAME.o $MODCFG"
    if ! $INSMOD $EMC2_DIR/rtlib/$MODNAME.o "$MODCFG" ; then
        echo "Realtime HAL module $MODNAME did not load..."
        echo "check system log for error messages"
#        cleanup
        exit -1
    fi
    # move on to next module
    MODNUM=$(($MODNUM+1))
    MODNAME=`$INIVAR -ini $INIFILE -var RTMOD$MODNUM -sec HAL`
done

# HAL user space module loading
MODNUM=1
MODNAME=`$INIVAR -ini $INIFILE -var USRMOD$MODNUM -sec HAL`
while [ -n "$MODNAME" ] ; do
    MODCFG=`$INIVAR -ini $INIFILE -var USRMODCFG$MODNUM -sec HAL`
    echo "Starting user space HAL module $MODNAME $MODCFG"
    $EMC2_DIR/bin/$MODNAME $MODCFG &
    # move on to next module
    MODNUM=$(($MODNUM+1))
    MODNAME=`$INIVAR -ini $INIFILE -var USRMOD$MODNUM -sec HAL`
done



exit 1

# Run emcio in background
echo -n "Starting EMC IO PROGRAM --  $EMCIO..."
case $EMCIO in
  bridgeportio|minimillio|simio|ppmcio)
    if [ ! -x EMC2_DIR/bin/$EMCIO ] ; then
      echo "can't run $EMCIO program"
      echo "The file $EMC2_DIR/bin/$EMCIO does not exist or is not executable."
#      cleanup
      exit 1
    fi
    if [ -f ${HOME}/.debug_emcio ] ; then
	xterm -sb -sl 1000 -e ${DEBUGGER} $EMC2_DIR/bin/$EMCIO  &
	echo "Press ENTER when the $EMCIO is running in the debugger."
	read foo
    else
	$EMC2_DIR/bin/$EMCIO -ini $INIFILE &
    fi
    echo "done"
  ;;
  tkio)
    if [ ! -x EMC2_DIR/bin/$EMCIO ] ; then
      echo "can't run $emcio program"
      echo "The file $EMC2_DIR/bin/$EMCIO does not exist or is not executable."
#      cleanup
      exit 1
    fi
    if [ -f ${HOME}/.debug_emcio ] ; then
	xterm -sb -sl 1000 -e ${DEBUGGER} $EMC2_DIR/bin/$EMCIO  &
	echo "Press ENTER when the $EMCIO is running in the debugger."
	read foo
    else
	$EMC2_DIR/bin/$EMCIO -ini $INIFILE &
    fi
    echo "done"
  ;;
  *)
    if [ ! -x $EMC2_DIR/bin/$EMCIO ] ; then
      echo "can't run $EMCIO program"
#      cleanup
      exit 1
    fi
    if [ -f ${HOME}/.debug_emcio ] ; then
	xterm -sb -sl 1000 -e ${DEBUGGER} $EMC2_DIR/bin/$EMCIO  &
	echo "Press ENTER when the $emcio is running in the debugger."
	read foo
    else
	$EMC2_DIR/bin/$EMCIO -ini $INIFILE &
    fi
    echo "done"
  ;;
esac

sleep 1

# Run emctask in background
echo -n "Starting EMC TASK PROGRAM -- $EMCTASK..."
case $EMCTASK in
  bridgeporttask|minimilltask)
    if [ ! -x $EMC2_DIR/bin/$EMCTASK ] ; then
      echo "can't run $EMCTASK program"
      echo "The file $EMC2_DIR/bin/$EMCTASK does not exist or is not executable."
#      cleanup
      exit 1
    fi
   if [ -f ${HOME}/.debug_emctask ] ; then
        xterm -sb -sl 1000 -e ${DEBUGGER} $EMC2_DIR/bin/$EMCTASK  &
        echo "Enter 'y' when the $emctask is running in the debugger."
	confirm=""
	while [ "${confirm}" != "y" ] ; do
	    read confirm
	done
    else
        $EMC2_DIR/bin/$EMCTASK -ini $INIFILE &
    fi
    echo "done"
  ;;
  *)
    if [ ! -x $EMC2_DIR/bin/$EMCTASK ] ; then
      echo "can't run $EMCTASK program"
      echo "The file $EMC2_DIR/bin/$EMCTASK does not exist or is not executable."
#      cleanup
      exit 1
    fi
    if [ -f ${HOME}/.debug_emctask ] ; then
        xterm -sb -sl 1000 -e ${DEBUGGER} $EMC2_DIR/bin/$EMCTASK  &
        echo "Press ENTER when the $emctask is running in the debugger."
        read foo
    else
        $EMC2_DIR/bin/$EMCTASK -ini $INIFILE &
    fi
    echo "done"
  ;;
esac

sleep 1

# Run emcserver in background, if necessary
case $EMCSERVER in
  emcsvr)
    if [ ! -x $EMC2_DIR/bin/$EMCSERVER ] ; then
      echo "can't run $EMCSERVER program"
      echo "The file $EMC2_DIR/bin/$EMCSERVER does not exist or is not executable."
#      cleanup
      exit 1
    fi
    echo -n "starting EMC SERVER PROGRAM -- $EMCSERVER..."
    $EMC2_DIR/bin/$EMCSERVER -ini $INIFILE &
    echo "done"
  ;;
  "")
  ;;
  *)
    if [ ! -x $EMC2_DIR/bin/$EMCSERVER ] ; then
      echo "can't run $EMCSERVER program"
      echo "The file $EMC2_DIR/bin/$EMCSERVER does not exist or is not executable."
#      cleanup
      exit 1
    fi
    echo -n "starting $EMCSERVER..."
    $EMC2_DIR/bin/$EMCSERVER -ini $INIFILE &
    echo "done"
  ;;
esac

sleep 1

# Run emcstrip in background, if necessary
case $EMCSTRIP in
  emcstripchart)
    if [ ! -x $EMC2_DIR/bin/$EMCSTRIP ] ; then
      echo "can't run $EMCSTRIP program"
      echo "The file $EMC2_DIR/bin/$EMCSTRIP does not exist or is not executable."
    else
      echo -n "starting $EMCSTRIP $EMCSTRIP_OPTIONS ..."
      $EMC2_DIR/bin/$EMCSTRIP $EMCSTRIP_OPTIONS -- -ini $INIFILE  &
      echo "done"
    fi
  ;;
  "")
  ;;
  *)
    if [ ! -x $EMC2_DIR/bin/$EMCSTRIP ] ; then
      echo "can't run $EMCSTRIP program"
      echo "The file $EMC2_DIR/bin/$EMCSTRIP does not exist or is not executable."
    else
      echo -n "starting $EMCSTRIP $EMCSTRIP_OPTIONS..."
      $EMC2_DIR/bin/$EMCSTRIP $EMCSTRIP_OPTIONS -- -ini $INIFILE &
      echo "done"
    fi
  ;;
esac

sleep 1

# Debugging information, remove later
ps -ael
ipcs
/sbin/lsmod

sleep 1

# Run display in foreground
echo "running EMC DISPLAY PROGRAM -- $EMCDISPLAY..."
case $EMCDISPLAY in
  xemc|yemc|emcpanel|keystick)
    if [ ! -x $EMC2_DIR/bin/$EMCDISPLAY ] ; then
      echo "can't run $EMCDISPLAY program"
      echo "The file $EMC2_DIR/bin/$EMCDISPLAY does not exist or is not executable."
#      cleanup
      exit 1
    fi
    $EMC2_DIR/bin/$EMCDISPLAY -ini $INIFILE
  ;;
  tkemc)
    if [ ! -x $EMC2_DIR/bin/$EMCDISPLAY ] ; then
      echo "can't run $EMCDISPLAY program"
      echo "The file $EMC2_DIR/bin/$EMCDISPLAY does not exist or is not executable."
#      cleanup
      exit 1
    fi
# need to run tkemc with -- arg to separate remaining args
    $EMC2_DIR/bin/$EMCDISPLAY -- -ini $INIFILE
  ;;
  *)
    if [ ! -x $EMC2_DIR/bin/$EMCDISPLAY ] ; then
      echo "can't run $EMCDISPLAY program"
      echo "The file $EMC2_DIR/bin/$EMCDISPLAY does not exist or is not executable."
#      cleanup
      exit 1
    fi
    $EMC2_DIR/bin/$EMCDISPLAY -ini $INIFILE
  ;;
esac

# the display won't return until you shut it down,
# so when you get here it's time to clean up

echo 'Press <ENTER> or <RETURN> to continue.'
read foo;


# Now display finished, so let's clean up
# cleanup

exit 0
