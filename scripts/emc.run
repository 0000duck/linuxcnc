#!/bin/bash
# usage: emc.run [options] [<ini-file>]
#
# options:
#     -v = verbose - prints info as it works
#     -d = echos script commands to screen for debugging
#
# if <ini-file> not specified, uses EMC2_DIR/configs/emc.ini
# if path specified, looks there, else looks in $EMC2_DIR/configs


DEBUG_FILE=/dev/null
PRINT_FILE=/dev/null

# check for some programs that we need
if ! which grep >$DEBUG_FILE || \
   ! which sed >$DEBUG_FILE || \
   ! which ps >$DEBUG_FILE || \
   ! which kill >$DEBUG_FILE || \
   ! which whoami >$DEBUG_FILE || \
   ! which awk >$DEBUG_FILE ; then
    echo "Sorry, a neccessary program couldn't be found"
    exit -1
fi
if [ -x /sbin/insmod ] ; then
    INSMOD=/sbin/insmod
else
    echo "Can't find insmod"
    exit -1
fi
if [ -x /sbin/rmmod ] ; then
    RMMOD=/sbin/rmmod
else
    echo "Can't find rmmod"
    exit -1
fi
if [ -x /sbin/lsmod ] ; then
    LSMOD=/sbin/lsmod
else
    echo "Can't locate lsmod"
    exit -1
fi
if [ -x /usr/bin/pidof ] ; then
    PIDOF=/usr/bin/pidof ;
elif [ -x /bin/pidof ] ; then
    PIDOF=/bin/pidof ;
elif [ -x /sbin/pidof ] ; then
    PIDOF=/sbin/pidof ;
else
    echo "Can't find pidof"
    exit -1
fi

# strip and process command line options
#
while echo $1 | grep ^- >$DEBUG_FILE ; do
    # found an option
    OPTION=$1
    # strip it
    shift
    # process options
    if [ $OPTION = "-d" ] ; then
	# enable echoing of script and command output
	set -x;
	DEBUG_FILE=/dev/tty
    elif [ $OPTION = "-v" ] ; then
	# enable printing of verbose messages
	PRINT_FILE=/dev/tty
    else
	echo "Unknown option '$OPTION'"
	exit -1
    fi
done

# check for root privliges - hope to remove the need for this later
if [ `whoami` != root ] ; then
    echo "Sorry, you must be root to run EMC"
    exit -1
fi

# Determine the EMC2 root directory
# get name and (possibly relative) path of this script
SCRIPT=`which $0 | grep $0`
# name of script
SCRIPT_NAME=`echo $SCRIPT | sed s#\^.\*/##`
# delete name to get path
SCRIPT_DIR=`echo $SCRIPT | sed s/$SCRIPT_NAME//`
# path might be relative - convert to absolute
SCRIPT_DIR=$(cd $SCRIPT_DIR ; pwd -P)
# strip the "/scripts" part to get the root of the
# EMC2 directory tree
EMC2_DIR=`echo $SCRIPT_DIR | sed s#/scripts## `

# make some useful paths
EMC2_BIN_DIR=$EMC2_DIR/bin
EMC2_TCL_DIR=$EMC2_DIR/tcl
EMC2_SCRIPT_DIR=$EMC2_DIR/scripts
EMC2_RTLIB_DIR=$EMC2_DIR/rtlib
EMC2_CONFIG_DIR=$EMC2_DIR/configs

echo EMC2_DIR=$EMC2_DIR >$PRINT_FILE
echo EMC2_BIN_DIR=$EMC2_BIN_DIR >$PRINT_FILE
echo EMC2_TCL_DIR=$EMC2_TCL_DIR >$PRINT_FILE
echo EMC2_SCRIPT_DIR=$EMC2_SCRIPT_DIR >$PRINT_FILE
echo EMC2_RTLIB_DIR=$EMC2_RTLIB_DIR >$PRINT_FILE
echo EMC2_CONFIG_DIR=$EMC2_CONFIG_DIR >$PRINT_FILE

# look for ini file
INIFILE=
if [ ! -n "$1" ] ; then
    INIFILE=$EMC2_CONFIG_DIR/emc.ini
elif echo $1 | grep / >$DEBUG_FILE ; then
    INIFILE=$1
else
    INIFILE=$EMC2_CONFIG_DIR/$1
fi
if [ ! -f $INIFILE ] ; then
    echo "Could not find ini file '$INIFILE'"
    exit -1
fi
echo INIFILE=$INIFILE >$PRINT_FILE

# Find out where the inivar program is
if [ -x $EMC2_BIN_DIR/inivar ] ; then
    INIVAR=$EMC2_BIN_DIR/inivar
else
    echo "Can't locate inivar program - should be in $EMC2_BIN_DIR/inivar"
    exit -1
fi
echo INIVAR=$INIVAR >$PRINT_FILE

# Find out where the halcmd program is
if [ -x $EMC2_BIN_DIR/halcmd ] ; then
    HALCMD=$EMC2_BIN_DIR/halcmd
else
    echo "Can't locate halcmd program - should be in $EMC2_BIN_DIR/halcmd"
    exit -1
fi
echo HALCMD=$HALCMD >$PRINT_FILE

# Find out where the realtime script is
if [ -x $EMC2_SCRIPT_DIR/realtime ] ; then
    REALTIME=$EMC2_SCRIPT_DIR/realtime
else
    echo "Can't locate realtime script - should be in $EMC2_SCRIPTS_DIR/realtime"
    exit -1
fi
echo REALTIME=$REALTIME >$PRINT_FILE

# extract info from the ini file that we will need later
# get name of RS274NGC parameter file
RS274NGC_PARAMFILE=`$INIVAR -ini $INIFILE -var PARAMETER_FILE -sec RS274NGC`
if [ ! -n "$RS274NGC_PARAMFILE" ] ; then
    echo "Can't find variable PARAMETER_FILE in section [RS274NGC] of file $INIFILE."
    exit -1
fi
echo RS274NGC_PARAMFILE=$RS274NGC_PARAMFILE >$PRINT_FILE

# get emcmot information
EMCMOT=`$INIVAR -ini $INIFILE -var EMCMOT -sec EMCMOT`
if [ ! -n "$EMCMOT" ] ; then
    echo "Can't find variable EMCMOT in section [EMCMOT] of file $INIFILE."
    exit -1
fi
echo EMCMOT=$EMCMOT >$PRINT_FILE

# get emcio information
EMCIO=`$INIVAR -ini $INIFILE -var EMCIO -sec EMCIO`
if [ ! -n "$EMCIO" ] ; then
    echo "Can't find variable EMCIO in section [EMCIO] of file $INIFILE."
    exit -1
fi
echo EMCIO=$EMCIO >$PRINT_FILE

# get emctask information
EMCTASK=`$INIVAR -ini $INIFILE -var TASK -sec TASK`
if [ ! -n "$EMCTASK" ] ; then
    echo "Can't find variable TASK in section [TASK] of file $INIFILE."
    exit -1
fi
echo EMCTASK=$EMCTASK >$PRINT_FILE

# get emcserver information
EMCSERVER=`$INIVAR -ini $INIFILE -var EMCSERVER -sec EMCSERVER`
# no check needed - if nothing found, nothing will run
echo EMCSERVER=$EMCSERVER >$PRINT_FILE

# get emcstrip information
EMSTRIP=`$INIVAR -ini $INIFILE -var EMCSTRIP -sec EMCSTRIP`
# if none found, it just won't run... but if found, check for options
if [ -n "$EMCSTRIP" ] ; then
    EMCSTRIP_OPTIONS=`$INIVAR -ini $INIFILE -var OPTIONS -sec EMCSTRIP`
fi
echo EMCSTRIP=$EMCSTRIP >$PRINT_FILE
echo EMCSTRIP_OPTIONS=$EMCSTRIP_OPTIONS >$PRINT_FILE

# get display information
EMCDISPLAY=`$INIVAR -ini $INIFILE -var DISPLAY -sec DISPLAY`
if [ ! -n "$EMCDISPLAY" ] ; then
    echo "Can't find variable DISPLAY in section [DISPLAY] of file $INIFILE.";
fi
echo EMCDISPLAY=$EMCDISPLAY >$PRINT_FILE

# get NML config information
NMLFILE=`$INIVAR -ini $INIFILE -var NML_FILE -sec EMC`
if [ ! -n "$NMLFILE" ] ; then
    echo "Can't find variable NML_FILE in section [EMC] of file $INIFILE.";
fi
echo NMLFILE=$NMLFILE >$PRINT_FILE

# DON'T KNOW WHAT THIS IS FOR
#
# ipckeys=`grep SHMEM $NMLFILE | gawk '{printf("%x ",$10);}'`

# Done gathering information, define a few functions
# Execution resumes after function definitions...

KILL_TASK=
KILL_TIMEOUT=10
#
function KillTaskWithTimeout() {
    KILL_PIDS=`$PIDOF $KILL_TASK`
    if [ ! -n "$KILL_PIDS" ] ; then
	echo "Could not find pid(s) for task $KILL_TASK"
	return -1
    fi
    for KILL_PID in $KILL_PIDS ; do
	echo "Killing task $KILL_TASK, PID=$KILL_PID" >$PRINT_FILE
	# first a "gentle" kill with signal TERM
	kill $KILL_PID
	WAIT=$KILL_TIMEOUT
	# wait and see if it dissappears
	while [ $WAIT -gt 1 ] ; do
	    # see if it's still alive
	    if ps $KILL_PID >$DEBUG_FILE ; then
		WAIT=$(($WAIT-1))
		sleep 1
	    else
		WAIT=0
	    fi
	done
	if [ $WAIT -gt 0 ] ; then
	    # gentle didn't work, get serious
	    echo "Timeout, trying kill -9" >$PRINT_FILE
	    kill -9 $KILL_PID
	    WAIT=$KILL_TIMEOUT
	    # wait and see if it dissappears
	    while [ $WAIT -gt 1 ] ; do
		# see if it's still alive
		if ps $KILL_PID >$DEBUG_FILE ; then
		    WAIT=$(($WAIT-1))
		    sleep 1
		else
		    WAIT=0
		fi
	    done
	fi
	if [ $WAIT -gt 0 ] ; then
	    echo "Could not kill task $KILL_TASK, PID=$KILL_PID"
	fi
    done
}


# define the cleanup function
#
# this cleanup function doesn't know or care what was actually
# loaded - it simply kills _any_ processes in it's list of emc
# components

function Cleanup() {

    echo "Shutting down and cleaning up EMC..."
    # Kill displays first - that should cause an orderly
    #   shutdown of the rest of emc
    for KILL_TASK in xemc yemc emcpanel keystick emcsh ; do
	if $PIDOF $KILL_TASK >$DEBUG_FILE ; then
	    KillTaskWithTimeout
	fi
    done
    sleep 1

    # now kill all the other user space components of emc
    for KILL_TASK in emcsvr emcstripchart bridgeporttask milltask minimilltask bridgeportio minimillio simio io; do
	if $PIDOF $KILL_TASK >$DEBUG_FILE ; then
	    KillTaskWithTimeout
	fi
    done

    # now the realtime stuff
    # check for rtapi
    if [ -n "` $LSMOD | awk -- '$1 ~ /^rtapi$/ { print $1 }'`" ] ; then
	# rtapi loaded, check for hal_lib
	if [ -n "` $LSMOD | awk -- '$1 ~ /^hal_lib$/ { print $1 }'`" ] ; then
	    # hal_lib loaded, stop realtime threads
	    $HALCMD stop
	    # check for any hal_meters
	    if $PIDOF halmeter >$DEBUG_FILE ; then
		# get rid of them
		KILL_TASK=halmeter
		KillTaskWithTimeout
	    fi
	    # check for any halcmds
	    if $PIDOF halcmd >$DEBUG_FILE ; then
		# get rid of them
		KILL_TASK=halcmd
		KillTaskWithTimeout
	    fi
	    # check for user space HAL components
	    HAL_USR_COMPS=`$HALCMD show comp | grep -v halcmd | awk -- '$2 ~ /^User$/ { print $3 }'`
	    # remove them
	    for HAL_COMP in $HAL_USR_COMPS ; do
		echo "Removing user space HAL component $HAL_COMP" >$PRINT_FILE
		KILL_TASK=$HAL_COMP
		KillTaskWithTimeout
	    done
	    # check for realtime HAL components (including motion module)
	    HAL_RT_COMPS=`$HALCMD show comp | awk -- '$2 ~ /^RT$/ { print $3 }'`
	    # remove them
	    for HAL_COMP in $HAL_RT_COMPS ; do
		echo "Removing realtime HAL component $HAL_COMP" >$PRINT_FILE
		$RMMOD $HAL_COMP
	    done
	fi
	# remove rtapi and RTOS modules
	$EMC2_SCRIPT_DIR/realtime stop
    fi

    # remove lock file
    if [ -f $LOCKFILE ] ; then
	rm $LOCKFILE
    fi

    echo "Cleanup done"
}


## STUFF FROM OLD CLEANUP, DON'T KNOW IF WE WILL NEED IT OR NOT
#
## Check to see if the inifile was changed. If not delete the unnecessary
## backup.
#
#
#  if [ -f $INIFILE.$DATESTRING ] ; then
#    if diff $INIFILE $INIFILE.$DATESTRING > $DEBUG_FILE ; then
#	echo $INIFILE was not changed.
#	\rm $INIFILE.$DATESTRING
#    else
#	echo $INIFILE was changed.
#	diff $INIFILE $INIFILE.$DATESTRING
#	diff $INIFILE $INIFILE.$DATESTRING >$INIFILE.$DATESTRING.diff
#	echo $INIFILE differences saved to $INIFILE.$DATESTRING.diff
#	\rm $INIFILE.$DATESTRING;
#    fi
#  else
#    DATESTRING=`date +%Y%m%d%H%M%S`
#    cp $INIFILE $INIFILE.$DATESTRING
#  fi
#
#
#    if [ -n "$RS274NGC_PARAMFILE" ] ; then
#	if [ -f $RS274NGC_PARAMFILE.$DATESTRING ] ; then
#	    if diff $RS274NGC_PARAMFILE $RS274NGC_PARAMFILE.$DATESTRING > $DEBUG_FILE ; then
#		echo $RS274NGC_PARAMFILE was not changed.
#		\rm $RS274NGC_PARAMFILE.$DATESTRING
#	    else
#		echo $RS274NGC_PARAMFILE was changed.
#		diff $RS274NGC_PARAMFILE $RS274NGC_PARAMFILE.$DATESTRING
#		diff $RS274NGC_PARAMFILE $RS274NGC_PARAMFILE.$DATESTRING >$RS274NGC_PARAMFILE.$DATESTRING.diff
#		echo $RS274NGC_PARAMFILE differences saved to $RS274NGC_PARAMFILE.$DATESTRING.diff
#		\rm $RS274NGC_PARAMFILE.$DATESTRING;
#	    fi
#	else
#	    cp $RS274NGC_PARAMFILE $RS274NGC_PARAMFILE.$DATESTRING
#	fi
#   fi
#
#    # Delete sharedmemory segments and semaphores
#    for key in $ipckeys ; do
#	id=`ipcs -m | grep $key | gawk '{print $2}'`
#	if [ ${#id} -gt 1 ] ; then
#	    echo "Removing shared memory " $id
#	    if [ "${PLATBASE}" = "sunos" ] ; then
#		ipcrm -m $id
#	    else
#		ipcrm shm $id
#	    fi
#	fi
#	id=`ipcs -s | grep $key | gawk '{print $2}'`
#	if [ ${#id} -gt 1 ] ; then
#	    echo "Removing semaphore" $id
#	    if [ "${PLATBASE}" = "sunos" ] ; then
#		ipcrm -s $id
#	    else
#		ipcrm sem $id
#	    fi
#	fi
#    done
#
#    if [ -z "$PURE_SIMULATION" ] ; then
#	if [ -x ./remove_realtime_base ] ; then
#	    ./remove_realtime_base
#	    sleep 1
#	fi
#    fi
#
#

# done with function definitions, execution resumes here

# Name of lock file to check for that signifies that EMC is up,
# to prevent multiple copies of controller
LOCKFILE=/tmp/emc.lock


# I don't think this is needed - if Cleanup is called, emc is
# gone, so the lock should always be deleted...
# if Cleanup is not called, the lock file should not be touched
#
# 'STARTED' is flag that's set only if we create lock file, so
# if we get ^C we won't delete a previous lock file
#set STARTED = 0

# Check for lock file
if [ -f $LOCKFILE ]; then
  echo -n "EMC is running -- restart it? [y/n] "
  read input
  case $input in
    y|Y)
      echo Cleaning up old emc...
      Cleanup
    ;;
    *)
      echo Not starting new emc
      exit 0
    ;;
  esac
fi
echo Starting emc...

# trap ^C so that it's called if user interrupts script
trap 'Cleanup ; exit 0' SIGINT SIGTERM

# Create the lock file
touch $LOCKFILE

# SKIP THE POPUP-Message FOR NOW
#echo "Hi!  Pretend this message is a nice popup graphic"
#
# pop up intro graphic
img=`$INIVAR -ini $INIFILE -var INTRO_GRAPHIC -sec DISPLAY`
imgtime=`$INIVAR -ini $INIFILE -var INTRO_TIME -sec DISPLAY`
if [ "$imgtime" = "" ] ; then
  imgtime=5
fi
if [ "$img" != "" ] ; then
  if [ -x $EMC2_TCL_DIR/bin/popimage ] ; then
    $EMC2_TCL_DIR/bin/popimage $EMC2_DIR/$img $imgtime &
  fi
fi

# Now we can finally start loading EMC

echo "Loading RealTime OS, RTAPI, and HAL_LIB" >$PRINT_FILE
if ! $EMC2_SCRIPT_DIR/realtime start ; then
    echo "Realtime system did not load"
    Cleanup
    exit -1
fi

#checking for Motion module extention
if [ -f $EMC2_RTLIB_DIR/$EMCMOT.o ] ; then
    EMCMOT=$EMCMOT.o
fi

if [ -f $EMC2_RTLIB_DIR/$EMCMOT.ko ] ; then
    EMCMOT=$EMCMOT.ko
fi

# Prepare to load real time motion module
echo "Loading EMC Motion module: $EMCMOT" >$PRINT_FILE
if [ ! -f $EMC2_RTLIB_DIR/$EMCMOT ] ; then
    echo "Can't find motion controller $EMC2_RTLIB_DIR/$EMCMOT"
    Cleanup
    exit -1
fi
# get SHMEM_KEY for user/emcmot shared memory area
SHMEM_KEY=`$INIVAR -ini $INIFILE -var SHMEM_KEY -sec EMCMOT`
if [ ! -n "$SHMEM_KEY" ] ; then
    echo "Can't find variable SHMEM_KEY in section [EMCMOT] of file $INIFILE."
    Cleanup
    exit -1
fi
# get thread periods
BASE_PERIOD_SEC=`$INIVAR -ini $INIFILE -var BASE_PERIOD -sec EMCMOT`
if [ ! -n "$BASE_PERIOD_SEC" ] ; then
    echo "Can't find variable BASE_PERIOD in section [EMCMOT] of file $INIFILE."
    Cleanup
    exit -1
fi
BASE_PERIOD_NSEC=`echo $BASE_PERIOD_SEC | awk -- '{printf "%d\n", $1*1000000000}'`
SERVO_PERIOD_SEC=`$INIVAR -ini $INIFILE -var SERVO_PERIOD -sec EMCMOT`
if [ ! -n "$SERVO_PERIOD_SEC" ] ; then
    echo "Can't find variable SERVO_PERIOD in section [EMCMOT] of file $INIFILE."
    Cleanup
    exit -1
fi
SERVO_PERIOD_NSEC=`echo $SERVO_PERIOD_SEC | awk -- '{printf "%d\n", $1*1000000000}'`
TRAJ_PERIOD_SEC=`$INIVAR -ini $INIFILE -var TRAJ_PERIOD -sec EMCMOT`
if [ ! -n "$TRAJ_PERIOD_SEC" ] ; then
    echo "Can't find variable TRAJ_PERIOD in section [EMCMOT] of file $INIFILE."
    Cleanup
    exit -1
fi
TRAJ_PERIOD_NSEC=`echo $TRAJ_PERIOD_SEC | awk -- '{printf "%d\n", $1*1000000000}'`

# load the motion module

echo "$EMC2_DIR/rtlib/$EMCMOT base_period=$BASE_PERIOD_NSEC servo_period=$SERVO_PERIOD_NSEC traj_period=$TRAJ_PERIOD_NSEC key=$SHMEM_KEY"

if ! $INSMOD $EMC2_DIR/rtlib/$EMCMOT base_period_nsec=$BASE_PERIOD_NSEC \
				     servo_period_nsec=$SERVO_PERIOD_NSEC \
				     traj_period_nsec=$TRAJ_PERIOD_NSEC \
				     key=$SHMEM_KEY ; then
    echo "Motion module $EMCMOT did not load..."
    echo "check system log for error messages"
    Cleanup
    exit -1
fi

# export the location of the HAL realtime modules so that
# "halcmd loadrt" can find them
export HAL_RTMOD_DIR=$EMC2_DIR/rtlib

# execute HALCMD config files (if any)
NUM=1
MAX=`$INIVAR -ini $INIFILE -var HALFILEMAX -sec HAL`
while [ $NUM -le $MAX ] ; do
    # get config file name from ini file
    CFGFILE=`$INIVAR -ini $INIFILE -var HALFILE$NUM -sec HAL`
    if [ -n "$CFGFILE" ] ; then
	if [ ! -f $EMC2_CONFIG_DIR/$CFGFILE ] ; then
	    echo "Can't find HAL config file: $EMC2_CONFIG_DIR/$CFGFILE"
	    Cleanup
	    exit -1
	fi
	echo "Running HAL config file $CFGFILE" >$PRINT_FILE
	if ! $HALCMD -i $INIFILE -f $EMC2_CONFIG_DIR/$CFGFILE ; then
	    echo "HAL config file $CFGFILE failed."
	    Cleanup
	    exit -1
	fi
    fi
    # move on to next file
    NUM=$(($NUM+1))
done

# execute discrete HAL commands from ini file (if any)
NUM=1
MAX=`$INIVAR -ini $INIFILE -var HALCMDMAX -sec HAL`
while [ $NUM -le $MAX ] ; do
    # get command from ini file
    HALCOMMAND=`$INIVAR -ini $INIFILE -var HALCMD$NUM -sec HAL`
    if [ -n "$HALCOMMAND" ] ; then
	echo "Running HAL command: $HALCOMMAND" >$PRINT_FILE
	if ! $HALCMD $HALCOMMAND ; then
	    echo "ini file HAL command $HALCOMMAND failed."
	    Cleanup
	    exit -1
	fi
    fi
    # move on to next command
    NUM=$(($NUM+1))
done

# start the realtime stuff ticking
$HALCMD start

# Run emcio in background
echo "Starting EMC IO program: $EMCIO" >$PRINT_FILE
if [ ! -x $EMC2_BIN_DIR/$EMCIO ] ; then
    echo "Can't execute IO program $EMC2_BIN_DIR/$EMCIO"
    Cleanup
    exit 1
fi
$EMC2_BIN_DIR/$EMCIO -ini $INIFILE &

# Run emctask in background
echo "Starting EMC TASK program: $EMCTASK" >$PRINT_FILE
if [ ! -x $EMC2_BIN_DIR/$EMCTASK ] ; then
    echo "Can't execute TASK program $EMC2_BIN_DIR/$EMCTASK"
    Cleanup
    exit 1
fi
$EMC2_BIN_DIR/$EMCTASK -ini $INIFILE &


# Run emcserver in background, if necessary
if [ -n "$EMCSERVER" ] ; then
    echo "Starting EMC server program: $EMCSERVER" >$PRINT_FILE
    if [ ! -x $EMC2_BIN_DIR/$EMCSERVER ] ; then
	echo "Can't execute server program $EMC2_BIN_DIR/$EMCSERVER"
	Cleanup
	exit 1
    fi
    $EMC2_BIN_DIR/$EMCSERVER -ini $INIFILE &
fi

# Run emcstrip in background, if necessary
if [ -n "$EMCSTRIP" ] ; then
    echo "Starting EMC stripchart program: $EMCSTRIP" >$PRINT_FILE
    if [ ! -x $EMC2_BIN_DIR/$EMCSTRIP ] ; then
	echo "Can't execute server program $EMC2_BIN_DIR/$EMCSTRIP"
	Cleanup
	exit 1
    fi
    $EMC2_BIN_DIR/$EMCSTRIP $EMCSTRIP_OPTIONS -- -ini $INIFILE &
fi

# Debugging information, remove later
ps -ael >$DEBUG_FILE
ipcs >$DEBUG_FILE
/sbin/lsmod >$DEBUG_FILE

sleep 1

# Run display in foreground
echo "Starting EMC DISPLAY program: $EMCDISPLAY" >$PRINT_FILE
case $EMCDISPLAY in
  tkemc)
    # tkemc is in the tcl directory, not the bin directory
    if [ ! -x $EMC2_TCL_DIR/$EMCDISPLAY.tcl ] ; then
	echo "Can't execute DISPLAY program $EMC2_TCL_DIR/$EMCDISPLAY.tcl"
	Cleanup
	exit 1
    fi
    $EMC2_TCL_DIR/$EMCDISPLAY.tcl -ini $INIFILE
  ;;
  dummy)
    # dummy display just waits for <ENTER>
    echo "DUMMY DISPLAY MODULE, press <ENTER> to continue."
    read foo;
  ;;
  *)
    # all other displays are assumed to be in the bin directory
    if [ ! -x $EMC2_BIN_DIR/$EMCDISPLAY ] ; then
	echo "Can't execute DISPLAY program $EMC2_BIN_DIR/$EMCDISPLAY"
	Cleanup
	exit 1
    fi
    $EMC2_BIN_DIR/$EMCDISPLAY -ini $INIFILE
  ;;
esac

# the display won't return until you shut it down,
# so when you get here it's time to clean up
Cleanup

exit 0

