#!/bin/bash
################################################################################
# usage: emc [options] [<ini-file>]
#
# options:
#     -v = verbose - prints info as it works
#     -d = echos script commands to screen for debugging
#
# this version calls emc2/tcl/bin/pickconfig.tcl to pick an ini file if one
# is not specified on the command line
#
################################################################################
# Author:
# License: GPL Version 2
# System: Linux
#    
# Copyright (c) 2004 All rights reserved.
#
# Last change:
# $Revision$
# $Author$
# $Date$
################################################################################

DEBUG_FILE=/dev/null
PRINT_FILE=/dev/null

################################################################################
# 1.1. strip and process command line options
################################################################################
while ARG=$1 ; ! [ "$ARG" = "${ARG#-}" ] ; do
    # argument is an option
    if [ $ARG = "-d" ] ; then
	# enable echoing of script and command output
	DEBUG_FILE=/dev/tty
	echo "Debug mode on" >$DEBUG_FILE
	set -x;
    elif [ $ARG = "-v" ] ; then
	# enable printing of verbose messages
	PRINT_FILE=/dev/tty
	echo "Verbose mode on" >$PRINT_FILE
    else
	echo "Unknown option '$ARG'"
	exit -1
    fi
    # discard option, check next argument
    shift
done

################################################################################
# 1.2. check for some programs that we need, values get replaced by configure  #
################################################################################
prefix=@prefix@
exec_prefix=@exec_prefix@

INSMOD="@INSMOD@"
RMMOD="@RMMOD@"
LSMOD=@LSMOD@
PIDOF=@PIDOF@
GREP=@GREP@
PS=@PS@
WHOAMI=@WHOAMI@
AWK=@AWK@
IPCS=@IPCS@
KILL=@KILL@

################################################################################
# 1.3. Directories                           values get replaced by configure  #
################################################################################

EMC2_HOME=@EMC2_HOME@

EMC2_BIN_DIR=@EMC2_BIN_DIR@
EMC2_TCL_DIR=@EMC2_TCL_DIR@
EMC2_HELP_DIR=@EMC2_HELP_DIR@
EMC2_RTLIB_DIR=@EMC2_RTLIB_DIR@
EMC2_CONFIG_DIR=@EMC2_CONFIG_DIR@
EMC2_USER_CONFIG_DIR='~/emc2/configs'
EMC2_SYSTEM_CONFIG_DIR=/usr/local/etc/emc2/configs
EMC2_NCFILES_DIR=@EMC2_NCFILES_DIR@
REALTIME=@REALTIME@
EMC2_IMAGEDIR=@EMC2_IMAGE_DIR@


MODULE_EXT=@MODEXT@ # module extension, used when insmod'ing
################################################################################
# 1.3. INIFILE                           find inifile to use                   #
################################################################################

if [ ! -z $1 ]; then
    case $1 in
      /*) INIFILE=$1 ;;
      *)  INIFILE=`pwd`/$1;;
    esac
fi

# 1.3.1. Determine if we have run-in place or installed system
RUN_IN_PLACE=@RUN_IN_PLACE@
echo RUN_IN_PLACE=$RUN_IN_PLACE >>$PRINT_FILE

EMC2VERSION="@EMC2VERSION@"; export EMC2VERSION

# common from here..
INIVAR=$EMC2_BIN_DIR/inivar
HALCMD=$EMC2_BIN_DIR/halcmd
PICKCONFIG=$EMC2_TCL_DIR/bin/pickconfig.tcl
EMC2_EMCSH=$EMC2_BIN_DIR/emcsh
EMC2_IOSH=$EMC2_BIN_DIR/iosh

echo EMC2_DIR=$EMC2_DIR >>$PRINT_FILE
echo EMC2_BIN_DIR=$EMC2_BIN_DIR >>$PRINT_FILE
echo EMC2_TCL_DIR=$EMC2_TCL_DIR >>$PRINT_FILE
echo EMC2_SCRIPT_DIR=$EMC2_SCRIPT_DIR >>$PRINT_FILE
echo EMC2_RTLIB_DIR=$EMC2_RTLIB_DIR >>$PRINT_FILE
echo EMC2_CONFIG_DIR=$EMC2_CONFIG_DIR >>$PRINT_FILE
echo INIVAR=$INIVAR >>$PRINT_FILE
echo HALCMD=$HALCMD >>$PRINT_FILE
echo SETUPCONFIG=$SETUPCONFIG >>$PRINT_FILE
echo EMC2_EMCSH=$EMC2_EMCSH >>$PRINT_FILE
echo EMC2_IOSH=$EMC2_IOSH >>$PRINT_FILE

# was an inifile specified on the command line?
if [ ! -n "$INIFILE" ] ; then
    # nothing specified, get from the user
    INIFILE=$($PICKCONFIG "$EMC2_USER_CONFIG_DIR:$EMC2_SYSTEM_CONFIG_DIR:$EMC2_CONFIG_DIR")
    # it returns either a path, or nothing at all
fi

if [ ! -n "$INIFILE" ] ; then
    # still nothing specified, exit
    exit -1
fi
# delete directories from path, save name only
INI_NAME=`echo $INIFILE | sed s#^.*/##`
# delete name from path to get directory
INI_DIR=`echo $INIFILE | sed s/$INI_NAME//`

echo "Machine configuration directory is '$INI_DIR'"
echo "Machine configuration file is '$INI_NAME'"

# make sure ini file exists (the tcl script just did this, so we could 
# eliminate this test, but it does no harm)

if [ ! -f $INIFILE ] ; then
    echo "Could not find ini file '$INIFILE'"
    exit -1
fi
echo INIFILE=$INIFILE >>$PRINT_FILE

################################################################################
# 2.  extract info from the ini file that we will need later
################################################################################
retval=

# 2.1. define helper function
function GetFromIni {
    #$1 var name   $2 - section name
    name=$1
    retval=`$INIVAR -ini $INIFILE -var $1 -sec $2 2>>$DEBUG_FILE`
    if [ ! -n "$1" ] ; then
	echo "Can't find variable $1 in section [$2] of file $INIFILE."
	exit -1
    fi
    echo "$name=$retval" >>$PRINT_FILE
}
# 2.2. get param file
GetFromIni PARAMETER_FILE RS274NGC 
RS274NGC_PARAMFILE=$retval

# 2.3. get emcmot information
GetFromIni EMCMOT EMCMOT 
EMCMOT=$retval$MODULE_EXT # add module extension

# 2.4. get emcio information
GetFromIni EMCIO EMCIO 
EMCIO=$retval

# 2.5. get emctask information
GetFromIni TASK TASK 
EMCTASK=$retval

# 2.6. get emcserver information
GetFromIni EMCSERVER EMCSERVER 
EMCSERVER=$retval

# 2.7. get emcstrip information
GetFromIni EMCSTRIP EMCSTRIP
EMCSTRIP=$retval
# if none found, it just won't run... but if found, check for options
if [ -n "$EMCSTRIP" ] ; then
    EMCSTRIP_OPTIONS=`$INIVAR -ini $INIFILE -var OPTIONS -sec EMCSTRIP 2>>$DEBUG_FILE`
fi
echo EMCSTRIP_OPTIONS=$EMCSTRIP_OPTIONS >>$PRINT_FILE

# 2.8. get display information
GetFromIni DISPLAY DISPLAY
EMCDISPLAY=$retval

# 2.9. get NML config information
GetFromIni NML_FILE EMC
NMLFILE=$retval

################################################################################
# 3. Done gathering information, define a few functions
# Execution resumes after function definitions...
################################################################################

KILL_TASK=
KILL_TIMEOUT=10

################################################################################
# 3.1. Kills a list of tasks with timeout
# if it doesn't work, kill -9 is used
################################################################################
function KillTaskWithTimeout() {
    if [ ! -n "$KILL_PIDS" ] ; then
	KILL_PIDS=`$PIDOF $KILL_TASK`
    fi
    if [ ! -n "$KILL_PIDS" ] ; then
	echo "Could not find pid(s) for task $KILL_TASK"
	return -1
    fi
    for KILL_PID in $KILL_PIDS ; do
	echo "Killing task $KILL_TASK, PID=$KILL_PID" >>$PRINT_FILE
	# first a "gentle" sudo kill with signal TERM
	$KILL $KILL_PID
	WAIT=$KILL_TIMEOUT
	# wait and see if it dissappears
	while [ $WAIT -gt 1 ] ; do
	    # see if it's still alive
	    if $PS $KILL_PID >>$DEBUG_FILE ; then
		WAIT=$(($WAIT-1))
		sleep 1
	    else
		WAIT=0
	    fi
	done
	if [ $WAIT -gt 0 ] ; then
	    # gentle didn't work, get serious
	    echo "Timeout, trying kill -9" >>$PRINT_FILE
	    $KILL -9 $KILL_PID
	    WAIT=$KILL_TIMEOUT
	    # wait and see if it dissappears
	    while [ $WAIT -gt 1 ] ; do
		# see if it's still alive
		if $PS $KILL_PID >>$DEBUG_FILE ; then
		    WAIT=$(($WAIT-1))
		    sleep 1
		else
		    WAIT=0
		fi
	    done
	fi
	if [ $WAIT -gt 0 ] ; then
	    echo "Could not kill task $KILL_TASK, PID=$KILL_PID"
	fi
	KILL_PIDS=
    done
}


################################################################################
# 3.2. define the cleanup function
#
# this cleanup function doesn't know or care what was actually
# loaded - it simply kills _any_ processes in it's list of emc
# components
################################################################################
function Cleanup() {

    echo "Shutting down and cleaning up EMC..."
    # Kill displays first - that should cause an orderly
    #   shutdown of the rest of emc
    for KILL_TASK in xemc yemc emcpanel keystick iosh emcsh axis ; do
	if $PIDOF $KILL_TASK >>$DEBUG_FILE ; then
	    KillTaskWithTimeout
	fi
    done
    sleep 1

    # now kill all the other user space components of emc
    for KILL_TASK in emcsvr emcstripchart bridgeporttask milltask minimilltask bridgeportio minimillio simio io classicladder; do
	if $PIDOF $KILL_TASK >>$DEBUG_FILE ; then
	    KillTaskWithTimeout
	fi
    done

    # check for halconfig, and bring it down if it's around
    if [ -n "`ps auxw | grep halconfig.tcl | awk {'print $2'}`" ] ; then
	KILL_PIDS=`ps auxw | grep halconfig.tcl | awk {'print $2'}`
	KillTaskWithTimeout
    fi

    # now the realtime stuff
    # check for rtapi
    if [ -n "` $LSMOD | $AWK -- '$1 ~ /^rtapi$/ { print $1 }'`" ] ; then
	# rtapi loaded, check for hal_lib
	if [ -n "` $LSMOD | $AWK -- '$1 ~ /^hal_lib$/ { print $1 }'`" ] ; then
	    # hal_lib loaded, stop realtime threads
	    $HALCMD stop
	    # check for any hal_meters
	    if $PIDOF halmeter >>$DEBUG_FILE ; then
		# get rid of them
		KILL_TASK=halmeter
		KillTaskWithTimeout
	    fi
	    # check for any halcmds
	    if $PIDOF halcmd >>$DEBUG_FILE ; then
		# get rid of them
		KILL_TASK=halcmd
		KillTaskWithTimeout
	    fi
	    # check for user space HAL components
	    HAL_USR_COMPS=`$HALCMD show comp | $GREP -v halcmd | $AWK -- '$2 ~ /^User$/ { print $3 }'`
	    # remove them
	    for HAL_COMP in $HAL_USR_COMPS ; do
		echo "Removing user space HAL component $HAL_COMP" >>$PRINT_FILE
		KILL_TASK=$HAL_COMP
		KillTaskWithTimeout
	    done
	    # check for realtime HAL components (including motion module)
	    HAL_RT_COMPS=`$HALCMD show comp | $AWK -- '$2 ~ /^RT$/ { print $3 }'`
	    # remove them
	    for HAL_COMP in $HAL_RT_COMPS ; do
		echo "Removing realtime HAL component $HAL_COMP" >>$PRINT_FILE
		$RMMOD $HAL_COMP
	    done
	fi
	# remove rtapi and RTOS modules
	echo "Removing HAL_LIB, RTAPI, and Real Time OS modules" >>$PRINT_FILE
	$REALTIME stop
    fi

    # remove lock file
    if [ -f $LOCKFILE ] ; then
	rm $LOCKFILE
    fi

    echo "Cleanup done"
}



################################################################################
# 4. done with function definitions, execution resumes here
################################################################################

# Name of lock file to check for that signifies that EMC is up,
# to prevent multiple copies of controller
LOCKFILE=/tmp/emc.lock

# Check for lock file
if [ -f $LOCKFILE ]; then
  if tty -s; then
    echo -n "EMC is still running.  Restart it? [Y/n] "
    read input; [ -z $input ] && input=y
  else
    input=$(wish <<EOF
wm wi .
puts [tk_messageBox -title EMC -message "EMC is still running.  Restart it?" -type yesno]
exit
EOF
)
  fi
  case $input in
    y|Y|yes)
      echo Cleaning up old emc...
      Cleanup
    ;;
    *)
      echo Not starting new emc
      exit 0
    ;;
  esac
fi
echo Starting emc...

# trap ^C so that it's called if user interrupts script
trap 'Cleanup ; exit 0' SIGINT SIGTERM

#put the EMC2_BIN_DIR in PATH
PATH=$EMC2_BIN_DIR:$PATH

# go to the dir where the ini file is
# either configs/<specific-config> when run-in-place, or
# /usr/local/share/emc/configs/<specific-config> (wherever it was installed)
cd $INI_DIR

# Create the lock file
touch $LOCKFILE

################################################################################
# 4.1. pop up intro graphic
################################################################################
img=`$INIVAR -ini $INIFILE -var INTRO_GRAPHIC -sec DISPLAY 2>>$DEBUG_FILE`
imgtime=`$INIVAR -ini $INIFILE -var INTRO_TIME -sec DISPLAY 2>>$DEBUG_FILE`
if [ "$imgtime" = "" ] ; then
  imgtime=5
fi
if [ "$img" != "" ] ; then
  if [ -x $EMC2_TCL_DIR/bin/popimage ] ; then
    $EMC2_TCL_DIR/bin/popimage $EMC2_IMAGEDIR/$img $imgtime &
  fi
fi

################################################################################
# 4.2. Now we can finally start loading EMC
################################################################################
echo "Loading Real Time OS, RTAPI, and HAL_LIB modules" >>$PRINT_FILE
if ! $REALTIME start ; then
    echo "Realtime system did not load"
    Cleanup
    exit -1
fi

# 4.3. Prepare to load real time motion module
echo "Loading EMC Motion module: $EMCMOT" >>$PRINT_FILE
if [ ! -f $EMC2_RTLIB_DIR/$EMCMOT ] ; then
    echo "Can't find motion controller $EMC2_RTLIB_DIR/$EMCMOT"
    Cleanup
    exit -1
fi
# 4.3.1. get SHMEM_KEY for user/emcmot shared memory area
GetFromIni SHMEM_KEY EMCMOT
SHMEM_KEY=$retval

# 4.3.2. get thread periods
GetFromIni BASE_PERIOD EMCMOT
BASE_PERIOD_SEC=$retval
BASE_PERIOD_NSEC=`echo $BASE_PERIOD_SEC | env LANG=C $AWK -- '{printf "%d\n", $1*1000000000}'`

GetFromIni SERVO_PERIOD EMCMOT
SERVO_PERIOD_SEC=$retval
SERVO_PERIOD_NSEC=`echo $SERVO_PERIOD_SEC | env LANG=C $AWK -- '{printf "%d\n", $1*1000000000}'`

GetFromIni TRAJ_PERIOD EMCMOT
TRAJ_PERIOD_SEC=$retval
TRAJ_PERIOD_NSEC=`echo $TRAJ_PERIOD_SEC | env LANG=C $AWK -- '{printf "%d\n", $1*1000000000}'`

# 4.3.3. load the motion module
echo "$EMC2_RTLIB_DIR/$EMCMOT base_period=$BASE_PERIOD_NSEC servo_period=$SERVO_PERIOD_NSEC traj_period=$TRAJ_PERIOD_NSEC key=$SHMEM_KEY" >>$PRINT_FILE

if ! $INSMOD $EMC2_RTLIB_DIR/$EMCMOT base_period_nsec=$BASE_PERIOD_NSEC \
		    		    servo_period_nsec=$SERVO_PERIOD_NSEC \
				    traj_period_nsec=$TRAJ_PERIOD_NSEC \
				    key=$SHMEM_KEY ; then
    echo "Motion module $EMCMOT did not load..."
    echo "check system log for error messages"
    Cleanup
    exit -1
fi

sleep 5

# 4.3.4. export the location of the HAL realtime modules so that
# "halcmd loadrt" can find them
export HAL_RTMOD_DIR=$EMC2_RTLIB_DIR

# 4.3.5. Run emcio in background
echo "Starting EMC IO program: $EMCIO" >>$PRINT_FILE
if [ ! -x $EMC2_BIN_DIR/$EMCIO ] ; then
    echo "Can't execute IO program $EMC2_BIN_DIR/$EMCIO"
    Cleanup
    exit 1
fi
$EMC2_BIN_DIR/$EMCIO -ini $INIFILE &

sleep 1

# 4.3.6. execute HALCMD config files (if any)
# get first config file name from ini file
NUM=1
CFGFILE=`$INIVAR -ini $INIFILE -var HALFILE -sec HAL -num $NUM 2>>$DEBUG_FILE`
while [ -n "$CFGFILE" ] ; do
    if [ ! -f $INI_DIR/$CFGFILE ] ; then
	echo "Can't find HAL config file: $INI_DIR/$CFGFILE"
	Cleanup
	exit -1
    else
	CFGFILE=$INI_DIR/$CFGFILE
    fi
    echo "Running HAL config file $CFGFILE" >>$PRINT_FILE
    if ! $HALCMD -i $INIFILE -f $CFGFILE ; then
	echo "HAL config file $CFGFILE failed."
	Cleanup
	exit -1
    fi
    # get next config file name from ini file
    NUM=$(($NUM+1))
    CFGFILE=`$INIVAR -ini $INIFILE -var HALFILE -sec HAL -num $NUM 2>>$DEBUG_FILE`
done

# 4.3.7. execute discrete HAL commands from ini file (if any)
# get first command from ini file
NUM=1
HALCOMMAND=`$INIVAR -ini $INIFILE -var HALCMD -sec HAL -num $NUM 2>>$DEBUG_FILE`
while [ -n "$HALCOMMAND" ] ; do
    if [ -n "$HALCOMMAND" ] ; then
	echo "Running HAL command: $HALCOMMAND" >>$PRINT_FILE
	if ! $HALCMD $HALCOMMAND ; then
	    echo "ini file HAL command $HALCOMMAND failed."
	    Cleanup
	    exit -1
	fi
    fi
    # get next command from ini file
    NUM=$(($NUM+1))
    HALCOMMAND=`$INIVAR -ini $INIFILE -var HALCMD -sec HAL -num $NUM 2>>$DEBUG_FILE`
done

# 4.3.8. start the realtime stuff ticking
$HALCMD start

# 4.3.9. Run emctask in background
echo "Starting EMC TASK program: $EMCTASK" >>$PRINT_FILE
if [ ! -x $EMC2_BIN_DIR/$EMCTASK ] ; then
    echo "Can't execute TASK program $EMC2_BIN_DIR/$EMCTASK"
    Cleanup
    exit 1
fi
$EMC2_BIN_DIR/$EMCTASK -ini $INIFILE &

# 4.3.10. Run emcserver in background, if necessary
if [ -n "$EMCSERVER" ] ; then
    echo "Starting EMC server program: $EMCSERVER" >>$PRINT_FILE
    if [ ! -x $EMC2_BIN_DIR/$EMCSERVER ] ; then
	echo "Can't execute server program $EMC2_BIN_DIR/$EMCSERVER"
	Cleanup
	exit 1
    fi
    $EMC2_BIN_DIR/$EMCSERVER -ini $INIFILE &
fi

# 4.3.11. Run emcstrip in background, if necessary
if [ -n "$EMCSTRIP" ] ; then
    echo "Starting EMC stripchart program: $EMCSTRIP" >>$PRINT_FILE
    if [ ! -x $EMC2_BIN_DIR/$EMCSTRIP ] ; then
	echo "Can't execute server program $EMC2_BIN_DIR/$EMCSTRIP"
	Cleanup
	exit 1
    fi
    $EMC2_BIN_DIR/$EMCSTRIP $EMCSTRIP_OPTIONS -- -ini $INIFILE &
fi

# Debugging information, remove later
$PS -ael >>$DEBUG_FILE
$IPCS >>$DEBUG_FILE
$LSMOD >>$DEBUG_FILE

sleep 1

#export some common directories, used by some of the GUI's
export EMC2_TCL_DIR=$EMC2_TCL_DIR
export EMC2_EMCSH=$EMC2_EMCSH
export EMC2_IOSH=$EMC2_IOSH
export EMC2_HELP_DIR=$EMC2_HELP_DIR
export REALTIME=$REALTIME
export HALCMD=$HALCMD

# 4.3.12. Run display in foreground
echo "Starting EMC DISPLAY program: $EMCDISPLAY" >>$PRINT_FILE
case $EMCDISPLAY in
  tkemc|mini)
    # tkemc and mini are in the tcl directory, not the bin directory
    if [ ! -x $EMC2_TCL_DIR/$EMCDISPLAY.tcl ] ; then
	echo "Can't execute DISPLAY program $EMC2_TCL_DIR/$EMCDISPLAY.tcl"
	Cleanup
	exit 1
    fi
    $EMC2_TCL_DIR/$EMCDISPLAY.tcl -ini $INIFILE
  ;;
  dummy)
    # dummy display just waits for <ENTER>
    echo "DUMMY DISPLAY MODULE, press <ENTER> to continue."
    read foo;
  ;;
  *)
    # all other displays are assumed to be in the bin directory
    if [ ! -x $EMC2_BIN_DIR/$EMCDISPLAY ] ; then
	echo "Can't execute DISPLAY program $EMC2_BIN_DIR/$EMCDISPLAY"
	Cleanup
	exit 1
    fi
    $EMC2_BIN_DIR/$EMCDISPLAY -ini $INIFILE
  ;;
esac

# the display won't return until you shut it down,
# so when you get here it's time to clean up
Cleanup

exit 0
