#!/bin/bash
#
# realtime	This shell script takes care of starting and stopping
#		realtime services
#
# chkconfig: - 97 97
# description: realtime loades modules for RTOS functionality



CheckConfig(){
    RTAPICONF=
    # check for rtapi.conf in /etc/ first...
    if [ -f /etc/rtapi.conf ] ; then
	RTAPICONF=/etc/rtapi.conf
    else
	# check in the emc2 scripts directory
	# $0 is the command to run this script
	# strip the script name to leave the path
	SCRIPT_DIR=`echo $0 | sed s#realtime## `
	# the path might be relative
	# convert it to an absolute path
	SCRIPT_DIR=$(cd $SCRIPT_DIR ; pwd -P)
	# now look for rtapi.conf there
	if [ -f $SCRIPT_DIR/rtapi.conf ] ; then
	    RTAPICONF=$SCRIPT_DIR/rtapi.conf
	fi
    fi
    if [ -z "$RTAPICONF" ] ; then
	echo "Missing rtapi.conf. Did you run 'make rtapi' ?"
	exit -1
    fi
    # Save the system variable MODPATH so that it can be
    # re-exported on exit.
    old_path=$MODPATH
    # Import the config
    source $RTAPICONF
    # Export the module path specified in the config.
    export MODPATH
    # Generate module lists for loading and unloading
    # lists contain RTOS modules plus RTAPI and HAL
    # unload list is in reverse order
    MODULES_LOAD=
    MODULES_UNLOAD=
    for module in $MODULES ; do
	MODULES_LOAD="$MODULES_LOAD $module"
	MODULES_UNLOAD="$module $MODULES_UNLOAD"
    done
    MODULES_LOAD="$MODULES_LOAD $RTLIB_DIR/rtapi.o $RTLIB_DIR/hal_lib.o"
    MODULES_UNLOAD="hal_lib rtapi $MODULES_UNLOAD"
}

CheckStatus(){
    # check loaded/unloaded status of modules
    for MOD in $MODULES_UNLOAD ; do
	if /sbin/lsmod | awk '{print $1}' | grep -x $MOD >/dev/null ; then
	    echo "$MOD is loaded"
	else
	    echo "$MOD is not loaded"
	fi
    done
}

CheckRoot(){
    # checks to see if the user is root
    # first try whoami, then id
    if type whoami >/dev/null 2>/dev/null ; then
	if [ ! `whoami` = root ] ; then
	    echo "ERROR:  You must be root to run this command"
	    DoExit
	    exit -1
	fi
    elif type id >/dev/null 2>/dev/null ; then
	if [ ! `id -u` = 0 ] ; then
	    echo "ERROR:  You must be root to run this command"
	    DoExit
	    exit -1
	fi
    fi
    # if we get here, either the user is root, or both whoami
    # and id don't exist on this system... in either case we
    # should attempt to load/unload modules, so we return
}

CheckMem(){
# check for user space processes using shared memory
    if [ -e /dev/mbuff ] ; then
	# device file exists, check for processes using it
	if /sbin/fuser -s /dev/mbuff 2>/dev/null; then
	    # at least one process is using it
	    echo "ERROR:  Can't remove RTLinux modules, kill the following process(es) first"
	    /sbin/fuser -v /dev/mbuff 2>/dev/null
	    DoExit
	    exit -1
	fi
    elif [ -e /dev/rtai_shm ] ; then
	# device file exists, check for processes using it
	if /sbin/fuser -s /dev/rtai_shm 2>/dev/null; then
	    # at least one process is using it
	    echo "ERROR:  Can't remove RTAI modules, kill the following process(es) first"
	    /sbin/fuser -v /dev/rtai_shm 2>/dev/null
	    DoExit
	    exit -1
	fi
    fi
}

Load(){
    if [ "$RTAI" = "3" ] ; then
	if [ "$VERBOSE" = "1" ] ; then
	    ( cd $EMC2_HOME/scripts ; $RTAI_LOAD --verbose )
	else
	    ( cd $EMC2_HOME/scripts ; $RTAI_LOAD )
	fi
    fi
    for MOD in $MODULES_LOAD ; do
	# check to see if the module is already installed
	if ! /sbin/lsmod | awk '{print $1}' | grep -x $MOD >/dev/null ; then
	    # install the module - use insmod
	    if [ "$VERBOSE" = "1" ] ; then
	        /sbin/insmod $MOD
	    else
	        /sbin/insmod $MOD 1>/dev/null 2>/dev/null
	    fi
        fi
    done
    if [ "$DEBUG" != "" ] && [ -w /proc/rtapi/debug ] ; then
        echo "$DEBUG" > /proc/rtapi/debug
    fi
}

CheckLoaded(){
# checks to see if rtapi and hal_lib modules were loaded
# (would like to check all modules, but some may not actually
#  be required or present on all systems)
    STATUS=
    for module in rtapi hal_lib ; do
	# check to see if the module is installed
	if ! /sbin/lsmod | awk '{print $1}' | grep -x $module >/dev/null ; then
	    echo "ERROR: Could not load '$module'"
	    STATUS=error
	fi
    done
    if [ -n "$STATUS" ] ; then
	DoExit
	exit -1
    fi
}

Unload(){
    # modprobe will unload *all* the modules in one hit
    # (as long as the ordering is the reverse of load order)
    /sbin/modprobe -r $MODULES_UNLOAD 2>/dev/null
}

CheckUnloaded(){
# checks to see if all modules were unloaded
    STATUS=
    for module in $MODULES_UNLOAD ; do
	# check to see if the module is installed
	if /sbin/lsmod | awk '{print $1}' | grep -x $module >/dev/null ; then
	    echo "ERROR: Could not unload '$module'"
	    STATUS=error
	fi
    done
    if [ -n "$STATUS" ] ; then
	DoExit
	exit -1
    fi
}

DoExit(){
    # Export the original MODPATH
    export MODPATH=$old_path
}

if [ "$1" = "-v" ] ; then
  CMD=$2
  VERBOSE=1
else
  CMD=$1
  VERBOSE=0
fi

case "$CMD" in
  start|load)
	CheckConfig
	CheckRoot
	Load
	CheckLoaded
	DoExit
	;;
  restart|reload)
	CheckConfig
	CheckRoot
	CheckMem
	Unload
	CheckUnloaded
	Load
	CheckLoaded
	DoExit
	;;
  stop|unload)
	CheckConfig
	CheckRoot
	CheckMem
	Unload
	CheckUnloaded
	DoExit
	;;
  status)
	CheckConfig
	CheckStatus
	DoExit
	;;
  *)
	echo "Usage: $0 {start|load|stop|unload|restart|reload|status}" >&2
	exit 1
	;;
esac

exit 0
