#!/bin/bash
# WPS: I changed the line above to reflect the fact that
# This is a 'bash' script, not a 'sh' script.
# Under Linux it doesn't matter but on our SUNS this script must be run
# with bash not sh. (at least not /bin/sh or /usr/bin/sh)
# On the SUNS there is no /bin/bash, so the error is to remind the user
# to find/install bash.

# Touch the file .debug_scripts in your home directory if you like
# to see all the commands echoed.
ERROR_OUT_FILE=/dev/null

if [ -f ${HOME}/.debug_scripts ] ; then
    set -x;
    ERROR_OUT_FILE=/dev/tty
fi

DEBUGGER=gdb
if [ -f ${HOME}/.debugger_name ] ; then
    DEBUGGER=`cat ${HOME}/.debugger_name | head -n 1`
fi


# Set the name of the .ini file, using emc.ini as default. Change this to
# your .ini file, if you don't use emc.ini.

INIFILE=generic.ini

# Everything past this point is automatic. You need not change anything here
# unless you want to customize things that can't be done in the .ini file,
# like running additional programs.

#------------------------------------------------------------------------------

# change to the directory containing this script
# cd $0/..

if [ "$0" != "./generic.run" ] ; then 
    path=$path:/usr/bin
    prog=`which $0 | grep $0`
    tail=`echo $prog | sed s#\^.\*/##`
    dir=`echo $prog | sed s/$tail//`
    cd $dir
fi

# override INIFILE, if it's first arg
iniarg=0
for arg in $* ; do
  if [ $iniarg -eq 1 ] ; then
    INIFILE=$arg
    iniarg=0
  else if [ $arg = "-ini" ] ; then
      iniarg=1
    fi
  fi
done
if [ $iniarg -eq 1 ] ; then
  echo "missing file name after -ini"
  exit 1
fi

DATESTRING=`date +%Y%m%d%H%M%S`
IOEXEC_NEEDED=0
PLAT=nonrealtime
RTPLAT=realtime

# Find out where the inivar program is, if it's not in the path.
# WPS changed this search algorithm because it would not necessarily find
# the correct version of inivar, in fact it picks the one that is first in
# the alphabet.
if [ -x plat/nonrealtime/bin/inivar ] ; then
    inivar=plat/nonrealtime/bin/inivar;
else
    if [ -x /usr/bin/inivar ] ; then
        inivar=/usr/bin/inivar;
    else
        echo "can't locate inivar program - not in plat/nonrealtime/bin/inivar or /usr/bin/inivar"
        exit 0;
    fi
fi

echo inivar = $inivar
echo INIFILE = $INIFILE

RS274NGC_PARAMFILE=`$inivar -ini $INIFILE -var PARAMETER_FILE -sec RS274NGC`
echo RS274NGC_PARAMFILE = $RS274NGC_PARAMFILE

# get emcmot information
emcmot=`$inivar -ini $INIFILE -var EMCMOT -sec EMCMOT`
if [ ! -n "$emcmot" ] ; then
    echo "Can't find variable EMCMOT in section [EMCMOT] of file $INIFILE.";
    exit -1;
fi

# get emcio information
emcio=`$inivar -ini $INIFILE -var EMCIO -sec EMCIO`
if [ ! -n "$emcio" ] ; then
    echo "Can't find variable EMCIO in section [EMCIO] of file $INIFILE.";
    exit -1
fi

# get emctask information
emctask=`$inivar -ini $INIFILE -var TASK -sec TASK`
if [ ! -n "$emctask" ] ; then
    echo "Can't find variable TASK in section [TASK] of file $INIFILE.";
    exit -1
fi

# get emcserver information
emcserver=`$inivar -ini $INIFILE -var EMCSERVER -sec EMCSERVER`

# get emcstrip information
emcstrip=`$inivar -ini $INIFILE -var EMCSTRIP -sec EMCSTRIP`
emcstrip_options=`$inivar -ini $INIFILE -var OPTIONS -sec EMCSTRIP`

# get display information
display=`$inivar -ini $INIFILE -var DISPLAY -sec DISPLAY`
if [ ! -n "$display" ] ; then
    echo "Can't find variable DISPLAY in section [DISPLAY] of file $INIFILE.";
fi

# Name of lock file to check for that signifies that EMC is up,
# to prevent multiple copies of controller
lockfile=/tmp/emc.lock

# 'started' is flag that's set only if we create lock file, so
# if we get ^C we won't delete a previous lock file
set started = 0

# Check for lock file
if [ -f $lockfile ]; then
  echo -n "emc is running-- restart it? [y/n] "
  read input
  case $input in
    y|Y)
      echo cleaning up old emc...
    ;;
    *)
      echo not starting new emc
      exit 0
    ;;
  esac
else
  echo starting emc...
fi

# Create the lock file
touch $lockfile

# Mark that we created it
started=1

tasktokill=""
killtasktimeout=10

function killtaskwithtimeout () {

    sudo killall -INT $tasktokill 2> ${ERROR_OUT_FILE}

	time=`date +%s`
	deadline=`echo $time+ $killtasktimeout | bc`
	while pidof $tasktokill > /dev/null ; do
	    if [ `date +%s` -gt $deadline ] ; then
		echo "Timedout waiting for $tasktokill to die. Upgrading to -KILL"
		break;
	    fi
	    echo Waiting for $tasktokill to die . . .
	    sudo killall -INT $tasktokill 2> ${ERROR_OUT_FILE}
	    sleep 1
	done
	time=`date +%s`
	deadline=`echo $time+ $killtasktimeout | $bccmd`
	while pidof $tasktokill > /dev/null ; do
	    if [ `date +%s` -gt $deadline ] ; then
		echo Timedout waiting for $tasktokill to die.
		break;
	    fi
	    echo Waiting for $tasktokill to die . . .
	    sudo killall -KILL $tasktokill 2> ${ERROR_OUT_FILE}
	    sleep 1
	done
}

nmlfile=`$inivar -ini $INIFILE -var NML_FILE -sec EMC`
ipckeys=`grep SHMEM $nmlfile | awk '{printf("%x ",$10);}'`

# define the cleanup function
function cleanup() {
    sudo kill -INT `ps -ae | grep lt- | awk '{print $1}'` >/dev/null 2>/dev/null
    sleep 2
    sudo kill -KILL `ps -ae | grep lt- | awk '{print $1}'` >/dev/null 2>/dev/null

# Kill any displays lying around
  case $display in
    xemc|yemc|emcpanel|keystick)
      tasktokill=$display
      killtaskwithtimeout	
    ;;
    tkemc|mini|smini)
      tasktokill=ioshsh
      killtaskwithtimeout
      tasktokill=emcsh
      killtaskwithtimeout
    ;;
    *)
      tasktokill=$display
      killtaskwithtimeout	
    ;;
  esac

# Kill any emcservers lying around
  case $emcserver in
    emcsvr)
      tasktokill=$emcserver
      killtaskwithtimeout	
    ;;
    "")
    ;;
    *)
      tasktokill=$emcserver
      killtaskwithtimeout	
    ;;
  esac

# Kill any emcstrips lying around
  case $emcstrip in
    emcstripchart)
      tasktokill=$emcstrip
      killtaskwithtimeout	
    ;;
    "")
    ;;
    *)
      tasktokill=$emcstrip
      killtaskwithtimeout	
    ;;
  esac

# Kill any emctasks lying around
  case $emctask in
    bridgeporttask|minimilltask)
      tasktokill=$emctask
      killtaskwithtimeout	
    ;;
    *)
      tasktokill=$emctask
      killtaskwithtimeout	
    ;;
  esac

# Kill any emcios lying around
  case $emcio in
    bridgeportio|minimillio|simio|ppmcio)
      tasktokill=$emcio
      killtaskwithtimeout	
    ;;
    tkio)
      tasktokill=iosh
      killtaskwithtimeout	
    ;;
    *)
      tasktokill=$emcio
      killtaskwithtimeout	
    ;;
  esac

# Kill any emcmots lying around
  case $emcmot in
    *.o)
      if sudo /sbin/lsmod | grep $(echo $emcmot | sed s/\\.o//g) >/dev/null
2>/dev/null ; then 	echo Removing module  $(echo $emcmot | sed s/\\.o//g)
	/sbin/rmmod $(echo $emcmot | sed s/\\.o//g) 
      fi
    ;;
    *)
      tasktokill=$emcmot
      killtaskwithtimeout	
    ;;
  esac

# remove the lock file, if we create it
  if [ "$started" = "1" ]; then        
    \rm -f $lockfile
  fi

# Check to see if the inifile was changed. If not delete the unnecessary 
# backup.



  if [ -f $INIFILE.$DATESTRING ] ; then 
    if diff $INIFILE $INIFILE.$DATESTRING > /dev/null ; then
	echo $INIFILE was not changed.
	\rm $INIFILE.$DATESTRING
    else
	echo $INIFILE was changed.
	diff $INIFILE $INIFILE.$DATESTRING
	diff $INIFILE $INIFILE.$DATESTRING >$INIFILE.$DATESTRING.diff
	echo $INIFILE differences saved to $INIFILE.$DATESTRING.diff
	\rm $INIFILE.$DATESTRING;
    fi
  else
    DATESTRING=`date +%Y%m%d%H%M%S`
    cp $INIFILE $INIFILE.$DATESTRING
  fi


    if [ -n "$RS274NGC_PARAMFILE" ] ; then
	if [ -f $RS274NGC_PARAMFILE.$DATESTRING ] ; then 
	    if diff $RS274NGC_PARAMFILE $RS274NGC_PARAMFILE.$DATESTRING > /dev/null ; then
		echo $RS274NGC_PARAMFILE was not changed.
		\rm $RS274NGC_PARAMFILE.$DATESTRING 
	    else
		echo $RS274NGC_PARAMFILE was changed.
		diff $RS274NGC_PARAMFILE $RS274NGC_PARAMFILE.$DATESTRING
		diff $RS274NGC_PARAMFILE $RS274NGC_PARAMFILE.$DATESTRING >$RS274NGC_PARAMFILE.$DATESTRING.diff
		echo $RS274NGC_PARAMFILE differences saved to $RS274NGC_PARAMFILE.$DATESTRING.diff
		\rm $RS274NGC_PARAMFILE.$DATESTRING;
	    fi
	else
	    cp $RS274NGC_PARAMFILE $RS274NGC_PARAMFILE.$DATESTRING
	fi
   fi

    # Delete sharedmemory segments and semaphores
    for key in $ipckeys ; do
	id=`ipcs -m | grep $key | awk '{print $2}'`
	if [ ${#id} -gt 1 ] ; then
	    echo "Removing shared memory " $id
	    sudo ipcrm shm $id 
	fi
	id=`ipcs -s | grep $key | awk '{print $2}'`
	if [ ${#id} -gt 1 ] ; then
	    echo "Removing semaphore" $id
	    sudo ipcrm sem $id
	fi
    done
    
    if [ -z "$PURE_SIMULATION" ] ; then
	if [ -x ./remove_realtime_base ] ; then
	    sudo ./remove_realtime_base
	    sleep 1
	fi
    fi
}
      
# call cleanup function
cleanup

# and trap ^C so that it's called if user interrupts script
trap 'cleanup ; exit 0' SIGINT

# pop up intro graphic
img=`$inivar -ini $INIFILE -var INTRO_GRAPHIC -sec DISPLAY`
imgtime=`$inivar -ini $INIFILE -var INTRO_TIME -sec DISPLAY`
if [ "$imgtime" = "" ] ; then
  imgtime=5
fi
if [ "$img" != "" ] ; then
  if [ -x plat/nonrealtime/bin/popimage ] ; then
    plat/nonrealtime/bin/popimage $img $imgtime &
  fi
fi

# install RT-Linux or RTAI modules
#if [ -z "$PURE_SIMULATION" ] ; then
#    ./install_realtime_base;
#fi

sleep 1

# run emcmot in background
echo "starting EMC MOTION PROGRAM -- $emcmot..."
optargs=""
pcount=`sudo /sbin/modinfo -p $emcmot | grep PERIOD | wc -l`
if [ $pcount -eq 1 ] ; then 
    period=`$inivar -ini $INIFILE -var PERIOD -sec EMCMOT`
    if [ "$period" != "" ]; then
	period=$(echo $period 1000000000 \* 1 / p c | dc)
    	optargs="$optargs PERIOD=$period"
    else
	echo "PERIOD not found"
    fi
fi

pcount=`sudo /sbin/modinfo -p $emcmot | grep STEPPING_TYPE | wc -l`
if [ $pcount -eq 1 ] ; then 
    stepping_type=`$inivar -ini $INIFILE -var STEPPING_TYPE -sec EMCMOT`
    if [ "$stepping_type" != "" ]; then
    	optargs="$optargs STEPPING_TYPE=$stepping_type"
    else
	echo "STEPPING_TYPE not found"
    fi
fi

pcount=`sudo /sbin/modinfo -p $emcmot | grep IO_BASE_ADDRESS | wc -l`
if [ $pcount -eq 1 ] ; then 
    io_address=`$inivar -ini $INIFILE -var IO_BASE_ADDRESS -sec EMCMOT`
    if [ "$io_address" != "" ]; then
    	optargs="$optargs IO_BASE_ADDRESS=$io_address"
	echo "IO_BASE_ADDRESS $io_address"
    else
	echo "IO_BASE_ADDRESS not found"
    fi
else
echo "NUTS********************"
fi

pcount=`sudo /sbin/modinfo -p $emcmot | grep DRO_BASE_ADDRESS | wc -l`
if [ $pcount -eq 1 ] ; then 
    dro_address=`$inivar -ini $INIFILE -var DRO_BASE_ADDRESS -sec EMCMOT`
    if [ "$dro_address" != "" ]; then
    	optargs="$optargs DRO_BASE_ADDRESS=$dro_address"
    else
	echo "DRO_BASE_ADDRESS not found"
    fi
fi

pcount=`sudo /sbin/modinfo -p $emcmot | grep SHMEM_KEY | wc -l`
if [ $pcount -eq 1 ] ; then 
    shmem_key=`$inivar -ini $INIFILE -var SHMEM_KEY -sec EMCMOT`
    if [ "$shmem_key" != "" ]; then
    	optargs="$optargs SHMEM_KEY=$shmem_key"
    else
	echo "SHMEM_KEY not found"
    fi
fi

echo "modprobe $emcmot $optargs"
if ! sudo /sbin/modprobe $emcmot $optargs; then
    echo "can't install $emcmot"
    cleanup
    exit 1
else
    echo "done"
fi

sleep 1


# Run emcio in background
echo -n "starting EMC IO PROGRAM --  $emcio..."
case $emcio in
  bridgeportio|minimillio|simio|ppmcio)
    if [ ! -x plat/nonrealtime/bin/$emcio ] ; then
      echo "can't run $emcio program"
      echo "The file plat/nonrealtime/bin/$emcio does not exist or is not executable."
      cleanup
      exit 1
    fi
    sudo plat/nonrealtime/bin/$emcio -ini $INIFILE &
    echo "done"
  ;;
  tkio)
    if [ ! -x plat/nonrealtime/bin/$emcio ] ; then
      echo "can't run $emcio program"
      echo "The file plat/nonrealtime/bin/$emcio does not exist or is not executable."
      cleanup
      exit 1
    fi
    sudo plat/nonrealtime/bin/$emcio -ini $INIFILE &
    echo "done"
  ;;
  *)
    if [ ! -x plat/nonrealtime/bin/$emcio ] ; then
      echo "can't run $emcio program"
      cleanup
      exit 1
    fi
    sudo plat/nonrealtime/bin/$emcio -ini $INIFILE &
    echo "done"
  ;;
esac

sleep 1

# Run emctask in background
echo -n "starting EMC TASK PROGRAM -- $emctask..."
case $emctask in
  bridgeporttask|minimilltask)
    if [ ! -x plat/nonrealtime/bin/$emctask ] ; then
      echo "can't run $emctask program"
      echo "The file plat/nonrealtime/bin/$emctask does not exist or is not executable."
      cleanup
      exit 1
    fi
   if [ -f ${HOME}/.debug_emctask ] ; then
        xterm -sb -sl 1000 -e ${DEBUGGER} plat/nonrealtime/bin/$emctask  &
        echo "Enter 'y' when the $emctask is running in the debugger."
	confirm=""
	while [ "${confirm}" != "y" ] ; do
	    read confirm
	done
    else
        plat/nonrealtime/bin/$emctask -ini $INIFILE &
    fi
    echo "done"
  ;;
  *)
    if [ ! -x plat/nonrealtime/bin/$emctask ] ; then
      echo "can't run $emctask program"
      echo "The file plat/nonrealtime/bin/$emctask does not exist or is not executable."
      cleanup
      exit 1
    fi
    if [ -f ${HOME}/.debug_emctask ] ; then
        xterm -sb -sl 1000 -e ${DEBUGGER} plat/nonrealtime/bin/$emctask  &
        echo "Press ENTER when the $emctask is running in the debugger."
        read foo
    else
        plat/nonrealtime/bin/$emctask -ini $INIFILE &
    fi
    echo "done"
  ;;
esac

sleep 1

# Run emcserver in background, if necessary
case $emcserver in
  emcsvr)
    if [ ! -x plat/nonrealtime/bin/$emcserver ] ; then
      echo "can't run $emcserver program"
      echo "The file plat/nonrealtime/bin/$emcserver does not exist or is not executable."
      cleanup
      exit 1
    fi
    echo -n "starting EMC SERVER PROGRAM -- $emcserver..."
    plat/nonrealtime/bin/$emcserver -ini $INIFILE &
    echo "done"
  ;;
  "")
  ;;
  *)
    if [ ! -x plat/nonrealtime/bin/$emcserver ] ; then
      echo "can't run $emcserver program"
      echo "The file plat/nonrealtime/bin/$emcserver does not exist or is not executable."
      cleanup
      exit 1
    fi
    echo -n "starting $emcserver..."
    plat/nonrealtime/bin/$emcserver -ini $INIFILE &
    echo "done"
  ;;
esac

sleep 1

# Run emcstrip in background, if necessary
case $emcstrip in
  emcstripchart)
    if [ ! -x plat/nonrealtime/bin/$emcstrip ] ; then
      echo "can't run $emcstrip program"
      echo "The file plat/nonrealtime/bin/$emcstrip does not exist or is not executable."
    fi
    echo -n "starting $emcstrip $emcstrip_options ..."
    plat/nonrealtime/bin/$emcstrip $emcstrip_options -- -ini $INIFILE  &
    echo "done"
  ;;
  "")
  ;;
  *)
    if [ ! -x plat/nonrealtime/bin/$emcstrip ] ; then
      echo "can't run $emcstrip program"
      echo "The file plat/nonrealtime/bin/$emcstrip does not exist or is not executable."
    fi
    echo -n "starting $emcstrip..."
    plat/nonrealtime/bin/$emcstrip $emcstrip_options -- -ini $INIFILE &
    echo "done"
  ;;
esac

sleep 1

if [ -f ~/.debug_scripts ] ; then
    ps -ael
    ipcs 
    /sbin/lsmod 
fi

# Run display in foreground
echo "running EMC DISPLAY PROGRAM -- $display..."
case $display in
  xemc|yemc|emcpanel|keystick)
    if [ ! -x plat/nonrealtime/bin/$display ] ; then
      echo "can't run $display program"
      echo "The file plat/nonrealtime/bin/$display does not exist or is not executable."
      cleanup
      exit 1
    fi
    plat/nonrealtime/bin/$display -ini $INIFILE
  ;;
  tkemc|mini|smini)
    if [ ! -x plat/nonrealtime/bin/$display ] ; then
      echo "can't run $display program"
      echo "The file plat/nonrealtime/bin/$display does not exist or is not executable."
      cleanup
      exit 1
    fi
# need to run tkemc with -- arg to separate remaining args
    plat/nonrealtime/bin/$display -- -ini $INIFILE
    sudo killall iosh
  ;;
  *)
    if [ ! -x plat/nonrealtime/bin/$display ] ; then
      echo "can't run $display program"
      echo "The file plat/nonrealtime/bin/$display does not exist or is not executable."
      cleanup
      exit 1
    fi
    plat/nonrealtime/bin/$display -ini $INIFILE
  ;;
esac

sleep 1

if [ -f ~/.debug_scripts -o -f ~/.pause_before_cleanup ] ; then
    echo 'Press <ENTER> or <RETURN> to continue.'
    read foo;
fi


# Now display finished, so let's clean up
cleanup

exit 0
