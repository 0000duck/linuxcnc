ifneq ($(KERNELRELEASE),)
# kbuild part of the makefile

ifeq ($(RTFLAGS),)
include $(PWD)/../Makefile.inc
endif

obj-m := rtapi.o

EXTRA_CFLAGS := $(RTFLAGS) -I/usr/include -D__MODULE__

else
# normal part of the makefile

# get the defs for CC, CFLAGS, LIB_DIR, etc.
include ../Makefile.inc

# Public headers
HEADERS = \
procfs_macros.h \
rtapi.h \
rtapi_app.h

# Private headers
PRIVHDRS = \
rtapi_common.h \
rtapi_proc.h \
vsnprintf.h

# Sources
SRCS = \
$(RTPREFIX)_ulapi.c

ifneq ($(MODULE_EXT),.ko)

RT_SRCS = \
$(RTPREFIX)_rtapi.c \
mathstubs.c

# Libraries to be created
LIBS = \
$(RTLIB_DIR)/rtapi.o \
$(RTTMP_DIR)/mathstubs.o

endif 

LIBS += \
$(LIB_DIR)/ulapi.o 

all: rtapi.conf headers $(LIBS)

# Generic rules
include ../Make.rules

ifndef KDIR
KDIR := /lib/modules/$(shell uname -r)/build
endif

PWD := $(shell pwd)

modules: headers
	cp $(RTPREFIX)_rtapi.c rtapi.c
	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) CC=$(CC) V=0 modules

examples:
	(cd examples; make all)

headers: def_headers
	(cd examples; make $@)

indent: def_indent
	(cd examples; make $@)

depend: def_depend
	(cd examples; make $@)

# note that we always clean the examples, even if not
# configured to make them
clean: def_clean kclean
	(cd examples; make $@)
	- rm -f $(EMC2_HOME)/scripts/rtapi.conf

kclean:
	- rm -f .*.cmd *.o* *.mod.* *.ko
	- rm -fR .tmp_versions 

# explicit rules to make libs from objs

ifneq ($(MODULE_EXT),.ko)

$(RTLIB_DIR)/rtapi.o : $(RTTMP_DIR)/$(RTPREFIX)_rtapi.o
	@ echo "Install rtapi.o in rtlib"
	- \install -p -m0664 $< $(RTLIB_DIR)/rtapi.o
else
# Rule to create a hard link to rtapi.c for kbuild
$(obj)/rtapi.c: $(src)/$(RTPREFIX)_rtapi.c
	cp -fl $(src)/$(RTPREFIX)_rtapi.c $(src)/rtapi.c
endif

$(LIB_DIR)/ulapi.o : $(TMP_DIR)/$(RTPREFIX)_ulapi.o
	@ echo "Install ulapi.o in lib"
	- \install -p -m0664 $< $(LIB_DIR)/ulapi.o

# This is a list of the realtime modules provided by the OS
# that are to be loaded - Some will not be present on certain
# systems, but they still need to be listed if systems that do have
# them are to work.
RTAI_MOD="adeos rtai rt_mem_mgr rtai_sched rtai_fifos rtai_shm rtai_libm"
# For RTAI-3, we need to condsider using the RTAI scripts to load these modules.
RTAI3_MOD="adeos rtai_hal rtai_ksched rtai_fifos rtai_shm rtai_sem rtai_math"
RTAI3_RUN="emc2:ksched+fifos+shm+sem+math"
RTL_MOD="rtl mbuff rtl_time rtl_sched rtl_posixio rtl_fifo"

# This rule allows the user to type "make rtapi.conf".
# The real rule to make the rtapi.conf file has the
# full path as its target
rtapi.conf: $(EMC2_HOME)/scripts/rtapi.conf

# This rule actually makes rtapi.conf.  By including Makefile.inc
# as a dependency we insure that rtapi.conf is regenerated
# on the first "make" after running ./configure.
$(EMC2_HOME)/scripts/rtapi.conf: $(SRC_DIR)/Makefile.inc
	@ echo "Generate $@"
	@ echo "# DO NOT EDIT THIS FILE !" > $@
	@ echo "# Autogenerated by 'make' on `date`" >> $@
	@ echo  >> $@
	@ echo "# A few parameters from emc2/Makefile.inc" >>$@
	@ echo "EMC2_HOME='$(EMC2_HOME)'" >>$@
	@ echo "MAN_DIR='$(MAN_DIR)'" >> $@
	@ echo "KERNELDIR='$(KERNELDIR)'" >> $@
	@ echo "RTLIB_DIR='$(RTLIB_DIR)'" >> $@
	@ echo  >> $@
	@ echo "# Sets the default DEBUG level" >> $@
	@ echo "DEBUG='3'" >> $@
	mod_dir=$$(find /lib/modules/`uname -r` -name "mbuff.o" -o -name "rtai_shm.o") ; \
	  if [ "$$mod_dir" = "" ] ; then \
	     echo  >> $@ ;\
	     echo "# Path to the realtime kernel modules" >> $@; \
	     echo "MODPATH='$(RTDIR)/modules'"  >> $@ ; \
	  fi
	@ echo >> $@
	@ echo "# List of realtime kernel modules to be loaded" >> $@
	@ if [ "$(RTAI)" = "3" ] ; then \
	    echo "MODULES='$(RTAI3_MOD)'" >> $@ ; \
	    echo "$(RTAI3_RUN)" > $(EMC2_HOME)/scripts/.runinfo ; \
	    echo "RTAI='$(RTAI)'" >> $@ ; \
	    echo "RTAI_LOAD='$(RTDIR)/bin/rtai-load'" >> $@ ; \
	elif [ "$(RTPREFIX)" = "rtai" ] ; then \
	    echo "MODULES='$(RTAI_MOD)'" >> $@ ; \
	elif [ "$(RTPREFIX)" = "rtl" ] ; then \
	    echo "MODULES='$(RTL_MOD)'" >> $@ ; \
	  fi

.PHONY: all examples headers depend indent install clean

endif