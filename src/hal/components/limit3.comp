component limit3 "Limit the output signal to fall between min and max, limit its slew rate to less than maxv per second, and limit its second derivative to less than maxa per second squared.  When the signal is a position, this means that the position, velocity, and acceleration are limited.";
pin in float in;
pin out float out;
pin in bit load "When TRUE, immediately set \\fBout\\fB to \\fBin\\fR, ignoring maxv and maxa";
pin in float min_=-1e20;
pin in float max_=1e20;
pin in float maxv=1e20;
pin in float maxa=1e20;
variable double in_old;
variable double out_old;
variable double out_vel;
function _;
license "GPL";
;;

#include "rtapi_math.h"

#define SET_NEXT_STATE(out_pos)				\
    do {						\
	out_old = out;					\
	out = out_pos;					\
	in_old = in;					\
	return;						\
    } while (0)

#define VALID_NEXT(pos) ((pos) <= max_pos && (pos) >= min_pos)

// Distance = avg. velocity * time
#define S_GIVEN_VI_VF_T(vi,vf,t) ((vf + vi)/2 * t)
// Time = chg. velocity / acceleration
#define T_GIVEN_VI_VF_A(vi,vf,a) (fabs((vf - vi) / a))
// Final velocity = initial velocity + acceleration * time
#define VF_GIVEN_VI_A_T(vi,a,t) (vi + a*t)

FUNCTION(_) {
    double in_pos_lim, in_vel, min_vel, max_vel, min_pos, max_pos;
    double stop_pos_max, stop_pos_min, stop_time_max, stop_time_min;
    double vel_match_time, vel_match_in_pos, vel_match_out_pos;
    int out_dir_rel;

    if (load) {
	// Apply first order limit
	in_pos_lim = fmin(max_, fmax(min_, in));
	SET_NEXT_STATE(in_pos_lim);
	return;
    }

    // Input velocity
    in_vel = (in - in_old) / fperiod;
    // Output velocity
    out_vel = 2 * (out-out_old)/fperiod - out_vel;
    // Most negative/positive velocity reachable in one period
    // - vf = vi + a * t
    min_vel = fmax(VF_GIVEN_VI_A_T(out_vel, -maxa, fperiod), -maxv);
    max_vel = fmin(VF_GIVEN_VI_A_T(out_vel,  maxa, fperiod),  maxv);
    // Most negative/positive position reachable in one period
    // - cur. pos + (distance to reach min/max vel in one period)
    min_pos = out + S_GIVEN_VI_VF_T(out_vel, min_vel, fperiod);
    max_pos = out + S_GIVEN_VI_VF_T(out_vel, max_vel, fperiod);

    // Direction of output movement relative to input movement
    out_dir_rel = (out_vel - in_vel < 0) ? -1 : 1;

    // Calculate shortest distance to stop after next step
    stop_time_max = T_GIVEN_VI_VF_A(  // - time to decel from max_vel to 0
	max_vel, 0.0, -maxa);
    stop_pos_max = max_pos            // - distance to stop from max_pos
	+ S_GIVEN_VI_VF_T(max_vel, 0.0, stop_time_max);
    stop_time_min = T_GIVEN_VI_VF_A(  // - time to decel from min_vel to 0
	min_vel, 0.0, -maxa);
    stop_pos_min = min_pos            // - distance to stop from min_pos
	+ S_GIVEN_VI_VF_T(min_vel, 0.0, stop_time_min);

    // Follow input signal:  match position and velocity
    // - min time for velocity match
    vel_match_time = fabs(out_vel-in_vel) / maxa;
    // - input position after velocity match
    vel_match_in_pos = in + in_vel * vel_match_time;
    // - output position after velocity match
    vel_match_out_pos = out
	+ out_vel * (vel_match_time+fperiod)
	+ 0.5 * (-out_dir_rel * maxa) * pow(vel_match_time,2);

    // Respect max/min position limits
    // 
    // - If not at the limit line but in danger of overshooting it,
    //   slow down
    if (stop_pos_max >= max_ && !VALID_NEXT(max_))    // can't follow max limit
	SET_NEXT_STATE(min_pos);
    if (stop_pos_min <= min_ && !VALID_NEXT(min_))    // can't follow min limit
	SET_NEXT_STATE(max_pos);
    // - If input signal is headed out of bounds, or headed in bounds
    //   but no danger of overshooting, the limit is the goal
    if ((vel_match_in_pos < min_)                     // Input below min limit
	|| (in <= min_ && vel_match_in_pos < vel_match_out_pos)) {
	if (VALID_NEXT(min_))
	    // Check if jumping right onto the limit at target velocity
	    // would violate accel constraints
	    // a = (vf-vi)/t; vf = (sf-si)/t
	    if (fabs(min_-out)/fperiod/fperiod > maxa)
		SET_NEXT_STATE(max_pos);              // - Accel away fm limit
	    else
		SET_NEXT_STATE(min_);                 // - Park at min limit
	else
	    SET_NEXT_STATE(min_pos);                  // - Head toward min limit
    }
    if ((vel_match_in_pos > max_)                     // Input above max limit
	|| (in >= max_ && vel_match_in_pos > vel_match_out_pos)) {
	if (VALID_NEXT(max_))
	    // Check if jumping right onto the limit at target velocity
	    // would violate accel constraints
	    if (fabs(max_-out)/fperiod/fperiod > maxa)
		SET_NEXT_STATE(min_pos);              // - Accel away fm limit
	    else
		SET_NEXT_STATE(max_);                 // - Park at max limit
	else
	    SET_NEXT_STATE(max_pos);                  // - Head toward max limit
    }

    // Follow input signal
    //
    // - Try to track input
    if (VALID_NEXT(in))
	SET_NEXT_STATE(in);
    // - Try to match position and velocity without overshooting
    if (out > in) {                                   // Output > input:
	if (vel_match_in_pos < vel_match_out_pos)     // - Not overshooting
	    SET_NEXT_STATE(min_pos);                  //   - Move closer
	else                                          // - Overshooting
	    SET_NEXT_STATE(max_pos);                  //   - Back off
    } else {                                          // Output <= input
	if (vel_match_in_pos > vel_match_out_pos)     // - Not overshooting
	    SET_NEXT_STATE(max_pos);                  //   - Move closer
	else                                          // - Overshooting
	    SET_NEXT_STATE(min_pos);                  //   - Back off
    }

    // Shouldn't get here
    SET_NEXT_STATE((max_pos-min_pos)/2);
}
