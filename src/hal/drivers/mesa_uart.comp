component mesa_uart "An example component demonstrating how to access the Hostmot2 UART";

description """This component creates 16 input and 16 output pins. It transmits 
mesa_uart.N.tx-bytes on the selected UART every thread cycle and reads up to 16
bytes each cycle out of the recieve FIFO and writes the values to the associated
output pins. mesa_uart.N.rx-bytes indicates how many pins have been written to. 
(pins > rx-bytes simply hold their previous value)

One important part of this example is how the UART names are passed in as a
string modparam, and used by each instance of the component.

The component takes parameters in the form of a comma-separated
list of UART instance names, for example:

\\fB loadrt mesa_uart uart_chans=hm2_5i23.0.uart.0,hm2_5i23.0.uart.7\\fR

Note that no spaces are allowed in the string unless it is delimited by double 
quotes. 

The UART instance names are printed to the dmesg buffer during the Hostmot2 
setup sequence, one for each bspi instance included in the bitfile loaded to 
each installed card during the Hostmot2 setup sequence. Type "dmesg" at the 
terminal prompt to view the output.

The component exports two functions, send and receive, which need to be added
to a realtime thread.

The above example will output data on UART channels 0 and 7 as expected, but the
HAL pins created by the component will be numbered in strict numerial order. 
eg UART 0 will have pins mesa_uart.0... and UART 7 mesa_uart.1...
The UART channels need not even be all on the same FPGA card. 

Read the documents on "comp" for help with writing realtime components:
http://www.linuxcnc.org/docview/html/hal/comp.html""";

author "Andy Pugh andy@bodgesoc.org";
license "GPL";

// undocumented feature of comp, and when it is interpreted this file has moved
include "../../../hal/drivers/mesa-hostmot2/hostmot2.h";

pin in u32 tx-data-##[16] "Data to be transmitted";
pin out u32 rx-data-##[16] "Data recieved";
pin in s32 tx-bytes "Number of bytes to transmit";
pin out s32 rx-bytes "Number of Bytes received";

variable char *name; // UART name

option extra_setup yes;
option count_function yes;

function send;
function receive;

;;

/* This uses the RTAPI_MP_ARRAY_STRING macro to load the list of UART channels
into an array. This is copied into the *name string of each */

char *uart_chans[18] = {0,};
RTAPI_MP_ARRAY_STRING(uart_chans, 16, "UART Channel names");

FUNCTION(send){
/* This function uses the hm2_uart_send function to transmit data see 
man hm2_uart_send for more information. Data may be up to 64 bytes in size*/
    
    unsigned char data[16];
    int i, count;
    count = tx_bytes;
    if (count > 16) count = 16;
    for (i = 0 ; i < count ; i++){
        data[i] = tx_data(i) & 0x000000FF; //NB [] index for array and () for pin.
    }
    count = hm2_uart_send(name, data, count);
}

FUNCTION(receive){
/* This function uses the hm2_uart_send function to transmit data. 
 See man hm2_uart_send for more information. 16 bytes in the Rx buffer*/
    
    int i;
    unsigned char data[16];
    rx_bytes = hm2_uart_read(name, data);
    for (i = 0 ; i < rx_bytes ; i++){
         rx_data(i) = data[i];
    }
}
    
EXTRA_SETUP(){
    name = uart_chans[extra_arg];
    // 115000bps, no delay, auto tx enable)
    hm2_uart_setup(name, 115200, 0x40, -1);
    return 0;
}




int get_count(void){
    int i;
    for (i= 0; uart_chans[i] != NULL && i < 16 ; i++){}
    return i;
}