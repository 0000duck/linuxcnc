#!/usr/bin/python
#    Copyright 2008 John Kasunich
#    License: GPL2

import sys
import os
import glob
import string
import re
import subprocess
import datetime
import time
import getopt

def run(*args):
    sys.stdout.flush()
    try:
        retcode = subprocess.call(args)
    except KeyboardInterrupt:
        # let the last output from map be printed
        time.sleep(1)
        print "ERROR: %s interrupted by user" % args[0]
        retcode = -1
    if retcode != 0:
        print "ERROR: %s failed - see above for error messages" % args[0]
        sys.exit(1)

def add_deps(fname):
    global dependencies
    # and see what it needs
    for entity in entities_needed[fname]:
	# does any file provide the entity?
	if not entity in entities_defined:
	    print "ERROR: entity '%s' (required by '%s') is not defined in any .vhd file" % ( entity, fname )
	    sys.exit(1)
	file_needed = entities_defined[entity]
	# do we already have it in the list?
	if not file_needed in dependencies:
	    # add it
	    add_deps(file_needed)
    for package in packages_needed[fname]:
	# does any file provide the package?
	if not package in packages_defined:
	    print "ERROR: package '%s' (required by '%s') is not defined in any .vhd file" % ( package, fname )
	    sys.exit(1)
	file_needed = packages_defined[package]
	# do we already have it in the list?
	if not file_needed in dependencies:
	    # add it
	    add_deps(file_needed)
    # add this file last, after everything it requires
    dependencies.append(fname)


def usage ():
    print "\nUsage: spec2bit foo.spec bar.board\n"
    print "  Reads foo.spec, which is a HostMot2 FPGA configuration spec,"
    print "  and bar.board, which describes a Mesa board, and builds a"
    print "  bitfile 'foo_bar.bit' which can be loaded into the FPGA on"
    print "  the specified board to implement the configuration.\n"

argc = len(sys.argv)
if argc != 3 :
    usage()
    sys.exit(2)
spec_fname = sys.argv[1]
board_fname = sys.argv[2]

# are the xilinx tools available?
if not "XILINX" in os.environ:
    print "Xilinx tools not in environment."
    print "Source 'xilinx/settings.sh' to set environment variables."
    sys.exit(1)

config_prefix = os.path.splitext(spec_fname)[0]
board_prefix = os.path.splitext(board_fname)[0]
prefix = board_prefix + "_" + config_prefix
print "prefix is: ", prefix

# read the spec file
if os.path.exists(spec_fname):
    execfile(spec_fname)
else:
    print "ERROR: spec file '%s' not found" % spec_fname
    sys.exit(1)

# make sure it provided the requred fields
retval = 0
names = ["config_pins", "module_id", "pin_desc"]
for v in names:
    if not vars().has_key(v):
        print "ERROR: field '%s' missing from spec '%s'" % (v, spec_fname)
	retval = 1
if retval == 1:
    sys.exit(2)

# read the board file
if os.path.exists(board_fname):
    execfile(board_fname)
else:
    print "ERROR: board file '%s' not found" % board_fname
    sys.exit(1)

# make sure it provided the requred fields
retval = 0
names = ["board_pins", "template", "device", "constraints", "extra_fields"]
for v in names:
    if not vars().has_key(v):
        print "ERROR: field '%s' missing from '%s'" % (v, board_fname)
	retval = 1
# board files may have additional board specific data
for v in extra_fields:
    if not vars().has_key(v):
        print "ERROR: extra field '%s' missing from '%s'" % (v, board_fname)
	retval = 1
if retval == 1:
    sys.exit(2)

# a few more checks before we do anything rash
if not board_pins == config_pins:
    print "ERROR: config needs %d pins, board has %d pins" % (config_pins, board_pins)
    sys.exit(1)
if not os.path.exists(template):
    print "ERROR: template '%s' not found" % template
    sys.exit(1)

# input files seem legit, remove old generated files
print "removing old generated files"
generated = [".vhd", ".prj", ".scr", ".ngc", ".syn.log", ".ngd", ".ngd.log",
             "map.log", ".nad", ".nbd", ".ncd", ".bit" ]
for extension in generated:
    fname = prefix+extension
    if os.path.exists(fname):
	print "  removing '%s'" % fname
        os.remove(fname)

# make a couple of directories
if not os.path.exists("tmp_syn"):
    os.mkdir("tmp_syn")
if not os.path.exists("work_syn"):
    os.mkdir("work_syn")

# generate top level VHDL file
toplevel_fname = prefix+".vhd"
print "generating top-level file '%s'" % toplevel_fname
substitutions = {"prefix" : prefix ,
                 "module_id" : module_id,
                 "pin_desc" : pin_desc }
for field in extra_fields:
    substitutions[field] = vars()[field]
# do the substitution and write output file
source = open(template, "r")
dest = open(toplevel_fname, "w")
dest.write("-- AUTOGENERATED FILE - DO NOT EDIT!\n\n")
dest.write("-- this file is:      %s\n" % toplevel_fname)
dest.write("-- generated from:\n")
dest.write("--   config spec:     %s\n" % spec_fname)
dest.write("--   and board data:  %s\n" % board_fname)
dest.write("-- using template:    %s\n" % template)
dest.write("-- generated on:      %s\n\n" % str(datetime.datetime.now()).split(".")[0] )
dest.write(string.Template(source.read()).substitute(substitutions))
dest.close();

# next step - dependency checking
print "calculating dependencies"

# VHDL doesn't have nice simple "include" directives that specify the
# file - instead it says "I need this or that entity" and it is up to
# the tools to figure out which file in the current directory defines
# that entity.  So we need to parse every .vhd file in the directory....

# we are looking for the following patterns:

# 1) "entity<whitespace><identifier><whitespace>is"
# which means that this file defines entity <identifier>
re1 = re.compile("entity\s+(\w+)\s+is")

# 2) "package<whitespace><identifier>whitespace>is"
# which means that this file defines package <identifier>
re2 = re.compile("package\s+(\w+)\s+is")

# 3) ":<optwhitespace>entity<whitespace><identifier><whitespace>"
# which means that this file needs entity <identifier>
re3 = re.compile(":\s*entity\s+(\w+)\s+")

# 4) "use<whitespace>work.<identifier>."
# which means that this file needs package <identifier>
re4 = re.compile("use\s+work\.(\w+)\.")

n = 0
# these two dicts will contain 'item : file-that-defines-item' pairs
entities_defined = dict()
packages_defined = dict()
# these two dicts will contain 'file : set-of-things-it-needs' pairs
entities_needed = dict()
packages_needed = dict()

filenames = glob.glob('*.vhd')
for filename in filenames:
    f = open(filename)
    tmp_entities_needed = set()
    tmp_packages_needed = set()

    for line in f:
        # remove comments (anything after '--')
        line = line.split("--",1)[0]
        # after each regexp search, match.group(1) is <identifier>
        # convert <identifier> to lowercase since VHDL is case insensitive

        match = re1.search(line)
        if match:
	    identifier = match.group(1).lower()
	    entities_defined[identifier] = filename	

        match = re2.search(line)
        if match:
	    identifier = match.group(1).lower()
	    packages_defined[identifier] = filename	

        match = re3.search(line)
        if match:
	    identifier = match.group(1).lower()
	    tmp_entities_needed.add(identifier)

        match = re4.search(line)
        if match:
	    identifier = match.group(1).lower()
	    tmp_packages_needed.add(identifier)

    f.close()
    # add the 'needed' sets for this file to the master dicts
    entities_needed[filename] = tmp_entities_needed
    packages_needed[filename] = tmp_packages_needed

# end of parsing - all info is in the four dicts

# recursively generate a list of dependencies
dependencies = []
add_deps(toplevel_fname)

# convert the dependency list into a .prj file
prj_fname = prefix + ".prj"
print "generating project file '%s'" % prj_fname
dest = open(prj_fname, "w")
for dep in dependencies:
    dest.write("vhdl work %s\n" % dep)
dest.write("nosort\n")
dest.close()

# determine the top level entity - the first one defined in the
# top level VHDL file

f = open(toplevel_fname)
for line in f:
    # remove comments (anything after '--')
    line = line.split("--",1)[0]
    # use the previously defined regexp to find the
    # first "entity <identifier> is" in the file
    match = re1.search(line)
    if match:
	toplevel_entity = match.group(1)
	break;
f.close()
print "top level entity is '%s'" % toplevel_entity

# generate the synthesis script
scr_fname = prefix + ".scr"
ngc_fname = prefix + ".ngc"
print "generating synthesis script '%s'" % scr_fname
dest = open(scr_fname, "w")
dest.write("set -tmpdir ./tmp_syn\n")
dest.write("set -xsthdpdir ./work_syn\n")
dest.write("run\n")
dest.write("-ifmt VHDL -ifn %s\n" % prj_fname )
dest.write("-top %s\n" % toplevel_entity )
dest.write("-ofmt NGC -ofn %s\n" % ngc_fname )
dest.write("-p %s\n" % device )
dest.close()

# the first real step in the toolchain: Synthesis
synlog_fname = prefix + ".syn.log"
print "invoking XST for synthesis"
run("xst", "-ifn", scr_fname, "-ofn", synlog_fname)

# merge the constraint file into the design
ngdlog_fname = prefix + ".ngd.log"
ngd_fname = prefix + ".ngd"
print "invoking NGDbuild to merge constraints from '%s'" % constraints
retcode = run("ngdbuild", "-uc", constraints, ngc_fname, ngd_fname)
# rename log file
os.rename(prefix+".bld", ngdlog_fname)

# the toolchain uses .ncd for unplaced, placed-but-not-routed, and
# placed-and-routed files This program uses distinct extensions to preserve the
# intermediate files, and my sanity

# first step of actual device fitting - mapping
maplog_fname = prefix + ".map.log"
nad_fname = prefix + ".map.ncd"
pcf_fname = prefix + ".pcf"
print "invoking map to fit design into device"
run("map", "-o", nad_fname, ngd_fname)

# second step: placing
#placelog_fname = prefix + "
nbd_fname = prefix + ".place.ncd"
print "invoking par to place design into device"
retcode = run("par", "-nopad", "-r", nad_fname, '-w', nbd_fname, pcf_fname)

# third step: routing
ncd_fname = prefix + ".ncd"
print "invoking par to route the design"
retcode = run( "par", "-p", nbd_fname, "-w", ncd_fname, pcf_fname)

# Fourth step: bitfile generation
bit_fname = prefix + ".bit"
print "invoking bitgen to create bitfile"
run("bitgen", "-w", ncd_fname, bit_fname, pcf_fname)

print "created bitfile", bit_fname
sys.stdout.flush()

sys.exit(0)
